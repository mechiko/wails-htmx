// Code generated by SQLBoiler 4.16.2 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package znakboil

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// ProductCardsAttribute is an object representing the database table.
type ProductCardsAttribute struct {
	ID                            int         `boil:"id" json:"id" toml:"id" yaml:"id"`
	IDProductCards                null.Int    `boil:"id_product_cards" json:"id_product_cards,omitempty" toml:"id_product_cards" yaml:"id_product_cards,omitempty"`
	AttrID                        null.Int    `boil:"attr_id" json:"attr_id,omitempty" toml:"attr_id" yaml:"attr_id,omitempty"`
	AttrName                      null.String `boil:"attr_name" json:"attr_name,omitempty" toml:"attr_name" yaml:"attr_name,omitempty"`
	AttrValueID                   null.String `boil:"attr_value_id" json:"attr_value_id,omitempty" toml:"attr_value_id" yaml:"attr_value_id,omitempty"`
	AttrValue                     null.String `boil:"attr_value" json:"attr_value,omitempty" toml:"attr_value" yaml:"attr_value,omitempty"`
	ValueID                       null.Int    `boil:"value_id" json:"value_id,omitempty" toml:"value_id" yaml:"value_id,omitempty"`
	AttrValueType                 null.String `boil:"attr_value_type" json:"attr_value_type,omitempty" toml:"attr_value_type" yaml:"attr_value_type,omitempty"`
	AttrGroupID                   null.Int    `boil:"attr_group_id" json:"attr_group_id,omitempty" toml:"attr_group_id" yaml:"attr_group_id,omitempty"`
	AttrGroupName                 null.String `boil:"attr_group_name" json:"attr_group_name,omitempty" toml:"attr_group_name" yaml:"attr_group_name,omitempty"`
	MeasureDate                   null.String `boil:"measure_date" json:"measure_date,omitempty" toml:"measure_date" yaml:"measure_date,omitempty"`
	PublishedDate                 null.String `boil:"published_date" json:"published_date,omitempty" toml:"published_date" yaml:"published_date,omitempty"`
	EffectiveDate                 null.String `boil:"effective_date" json:"effective_date,omitempty" toml:"effective_date" yaml:"effective_date,omitempty"`
	ExpiredDate                   null.String `boil:"expired_date" json:"expired_date,omitempty" toml:"expired_date" yaml:"expired_date,omitempty"`
	LocationID                    null.String `boil:"location_id" json:"location_id,omitempty" toml:"location_id" yaml:"location_id,omitempty"`
	PartyLocationID               null.String `boil:"party_location_id" json:"party_location_id,omitempty" toml:"party_location_id" yaml:"party_location_id,omitempty"`
	Level                         null.String `boil:"level" json:"level,omitempty" toml:"level" yaml:"level,omitempty"`
	Gtin                          null.String `boil:"gtin" json:"gtin,omitempty" toml:"gtin" yaml:"gtin,omitempty"`
	Multiplier                    null.Int    `boil:"multiplier" json:"multiplier,omitempty" toml:"multiplier" yaml:"multiplier,omitempty"`
	CertificateNumber             null.String `boil:"certificate_number" json:"certificate_number,omitempty" toml:"certificate_number" yaml:"certificate_number,omitempty"`
	CertificateIssuedDate         null.String `boil:"certificate_issued_date" json:"certificate_issued_date,omitempty" toml:"certificate_issued_date" yaml:"certificate_issued_date,omitempty"`
	CertificateValidUntilDate     null.String `boil:"certificate_valid_until_date" json:"certificate_valid_until_date,omitempty" toml:"certificate_valid_until_date" yaml:"certificate_valid_until_date,omitempty"`
	CertificateApplicant          null.String `boil:"certificate_applicant" json:"certificate_applicant,omitempty" toml:"certificate_applicant" yaml:"certificate_applicant,omitempty"`
	CertificateManufacturer       null.String `boil:"certificate_manufacturer" json:"certificate_manufacturer,omitempty" toml:"certificate_manufacturer" yaml:"certificate_manufacturer,omitempty"`
	CertificateProductDescription null.String `boil:"certificate_product_description" json:"certificate_product_description,omitempty" toml:"certificate_product_description" yaml:"certificate_product_description,omitempty"`

	R *productCardsAttributeR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L productCardsAttributeL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var ProductCardsAttributeColumns = struct {
	ID                            string
	IDProductCards                string
	AttrID                        string
	AttrName                      string
	AttrValueID                   string
	AttrValue                     string
	ValueID                       string
	AttrValueType                 string
	AttrGroupID                   string
	AttrGroupName                 string
	MeasureDate                   string
	PublishedDate                 string
	EffectiveDate                 string
	ExpiredDate                   string
	LocationID                    string
	PartyLocationID               string
	Level                         string
	Gtin                          string
	Multiplier                    string
	CertificateNumber             string
	CertificateIssuedDate         string
	CertificateValidUntilDate     string
	CertificateApplicant          string
	CertificateManufacturer       string
	CertificateProductDescription string
}{
	ID:                            "id",
	IDProductCards:                "id_product_cards",
	AttrID:                        "attr_id",
	AttrName:                      "attr_name",
	AttrValueID:                   "attr_value_id",
	AttrValue:                     "attr_value",
	ValueID:                       "value_id",
	AttrValueType:                 "attr_value_type",
	AttrGroupID:                   "attr_group_id",
	AttrGroupName:                 "attr_group_name",
	MeasureDate:                   "measure_date",
	PublishedDate:                 "published_date",
	EffectiveDate:                 "effective_date",
	ExpiredDate:                   "expired_date",
	LocationID:                    "location_id",
	PartyLocationID:               "party_location_id",
	Level:                         "level",
	Gtin:                          "gtin",
	Multiplier:                    "multiplier",
	CertificateNumber:             "certificate_number",
	CertificateIssuedDate:         "certificate_issued_date",
	CertificateValidUntilDate:     "certificate_valid_until_date",
	CertificateApplicant:          "certificate_applicant",
	CertificateManufacturer:       "certificate_manufacturer",
	CertificateProductDescription: "certificate_product_description",
}

var ProductCardsAttributeTableColumns = struct {
	ID                            string
	IDProductCards                string
	AttrID                        string
	AttrName                      string
	AttrValueID                   string
	AttrValue                     string
	ValueID                       string
	AttrValueType                 string
	AttrGroupID                   string
	AttrGroupName                 string
	MeasureDate                   string
	PublishedDate                 string
	EffectiveDate                 string
	ExpiredDate                   string
	LocationID                    string
	PartyLocationID               string
	Level                         string
	Gtin                          string
	Multiplier                    string
	CertificateNumber             string
	CertificateIssuedDate         string
	CertificateValidUntilDate     string
	CertificateApplicant          string
	CertificateManufacturer       string
	CertificateProductDescription string
}{
	ID:                            "product_cards_attributes.id",
	IDProductCards:                "product_cards_attributes.id_product_cards",
	AttrID:                        "product_cards_attributes.attr_id",
	AttrName:                      "product_cards_attributes.attr_name",
	AttrValueID:                   "product_cards_attributes.attr_value_id",
	AttrValue:                     "product_cards_attributes.attr_value",
	ValueID:                       "product_cards_attributes.value_id",
	AttrValueType:                 "product_cards_attributes.attr_value_type",
	AttrGroupID:                   "product_cards_attributes.attr_group_id",
	AttrGroupName:                 "product_cards_attributes.attr_group_name",
	MeasureDate:                   "product_cards_attributes.measure_date",
	PublishedDate:                 "product_cards_attributes.published_date",
	EffectiveDate:                 "product_cards_attributes.effective_date",
	ExpiredDate:                   "product_cards_attributes.expired_date",
	LocationID:                    "product_cards_attributes.location_id",
	PartyLocationID:               "product_cards_attributes.party_location_id",
	Level:                         "product_cards_attributes.level",
	Gtin:                          "product_cards_attributes.gtin",
	Multiplier:                    "product_cards_attributes.multiplier",
	CertificateNumber:             "product_cards_attributes.certificate_number",
	CertificateIssuedDate:         "product_cards_attributes.certificate_issued_date",
	CertificateValidUntilDate:     "product_cards_attributes.certificate_valid_until_date",
	CertificateApplicant:          "product_cards_attributes.certificate_applicant",
	CertificateManufacturer:       "product_cards_attributes.certificate_manufacturer",
	CertificateProductDescription: "product_cards_attributes.certificate_product_description",
}

// Generated where

var ProductCardsAttributeWhere = struct {
	ID                            whereHelperint
	IDProductCards                whereHelpernull_Int
	AttrID                        whereHelpernull_Int
	AttrName                      whereHelpernull_String
	AttrValueID                   whereHelpernull_String
	AttrValue                     whereHelpernull_String
	ValueID                       whereHelpernull_Int
	AttrValueType                 whereHelpernull_String
	AttrGroupID                   whereHelpernull_Int
	AttrGroupName                 whereHelpernull_String
	MeasureDate                   whereHelpernull_String
	PublishedDate                 whereHelpernull_String
	EffectiveDate                 whereHelpernull_String
	ExpiredDate                   whereHelpernull_String
	LocationID                    whereHelpernull_String
	PartyLocationID               whereHelpernull_String
	Level                         whereHelpernull_String
	Gtin                          whereHelpernull_String
	Multiplier                    whereHelpernull_Int
	CertificateNumber             whereHelpernull_String
	CertificateIssuedDate         whereHelpernull_String
	CertificateValidUntilDate     whereHelpernull_String
	CertificateApplicant          whereHelpernull_String
	CertificateManufacturer       whereHelpernull_String
	CertificateProductDescription whereHelpernull_String
}{
	ID:                            whereHelperint{field: "[dbo].[product_cards_attributes].[id]"},
	IDProductCards:                whereHelpernull_Int{field: "[dbo].[product_cards_attributes].[id_product_cards]"},
	AttrID:                        whereHelpernull_Int{field: "[dbo].[product_cards_attributes].[attr_id]"},
	AttrName:                      whereHelpernull_String{field: "[dbo].[product_cards_attributes].[attr_name]"},
	AttrValueID:                   whereHelpernull_String{field: "[dbo].[product_cards_attributes].[attr_value_id]"},
	AttrValue:                     whereHelpernull_String{field: "[dbo].[product_cards_attributes].[attr_value]"},
	ValueID:                       whereHelpernull_Int{field: "[dbo].[product_cards_attributes].[value_id]"},
	AttrValueType:                 whereHelpernull_String{field: "[dbo].[product_cards_attributes].[attr_value_type]"},
	AttrGroupID:                   whereHelpernull_Int{field: "[dbo].[product_cards_attributes].[attr_group_id]"},
	AttrGroupName:                 whereHelpernull_String{field: "[dbo].[product_cards_attributes].[attr_group_name]"},
	MeasureDate:                   whereHelpernull_String{field: "[dbo].[product_cards_attributes].[measure_date]"},
	PublishedDate:                 whereHelpernull_String{field: "[dbo].[product_cards_attributes].[published_date]"},
	EffectiveDate:                 whereHelpernull_String{field: "[dbo].[product_cards_attributes].[effective_date]"},
	ExpiredDate:                   whereHelpernull_String{field: "[dbo].[product_cards_attributes].[expired_date]"},
	LocationID:                    whereHelpernull_String{field: "[dbo].[product_cards_attributes].[location_id]"},
	PartyLocationID:               whereHelpernull_String{field: "[dbo].[product_cards_attributes].[party_location_id]"},
	Level:                         whereHelpernull_String{field: "[dbo].[product_cards_attributes].[level]"},
	Gtin:                          whereHelpernull_String{field: "[dbo].[product_cards_attributes].[gtin]"},
	Multiplier:                    whereHelpernull_Int{field: "[dbo].[product_cards_attributes].[multiplier]"},
	CertificateNumber:             whereHelpernull_String{field: "[dbo].[product_cards_attributes].[certificate_number]"},
	CertificateIssuedDate:         whereHelpernull_String{field: "[dbo].[product_cards_attributes].[certificate_issued_date]"},
	CertificateValidUntilDate:     whereHelpernull_String{field: "[dbo].[product_cards_attributes].[certificate_valid_until_date]"},
	CertificateApplicant:          whereHelpernull_String{field: "[dbo].[product_cards_attributes].[certificate_applicant]"},
	CertificateManufacturer:       whereHelpernull_String{field: "[dbo].[product_cards_attributes].[certificate_manufacturer]"},
	CertificateProductDescription: whereHelpernull_String{field: "[dbo].[product_cards_attributes].[certificate_product_description]"},
}

// ProductCardsAttributeRels is where relationship names are stored.
var ProductCardsAttributeRels = struct {
}{}

// productCardsAttributeR is where relationships are stored.
type productCardsAttributeR struct {
}

// NewStruct creates a new relationship struct
func (*productCardsAttributeR) NewStruct() *productCardsAttributeR {
	return &productCardsAttributeR{}
}

// productCardsAttributeL is where Load methods for each relationship are stored.
type productCardsAttributeL struct{}

var (
	productCardsAttributeAllColumns            = []string{"id", "id_product_cards", "attr_id", "attr_name", "attr_value_id", "attr_value", "value_id", "attr_value_type", "attr_group_id", "attr_group_name", "measure_date", "published_date", "effective_date", "expired_date", "location_id", "party_location_id", "level", "gtin", "multiplier", "certificate_number", "certificate_issued_date", "certificate_valid_until_date", "certificate_applicant", "certificate_manufacturer", "certificate_product_description"}
	productCardsAttributeColumnsWithoutDefault = []string{"id_product_cards", "attr_id", "attr_name", "attr_value_id", "attr_value", "value_id", "attr_value_type", "attr_group_id", "attr_group_name", "measure_date", "published_date", "effective_date", "expired_date", "location_id", "party_location_id", "level", "gtin", "multiplier", "certificate_number", "certificate_issued_date", "certificate_valid_until_date", "certificate_applicant", "certificate_manufacturer", "certificate_product_description"}
	productCardsAttributeColumnsWithDefault    = []string{"id"}
	productCardsAttributePrimaryKeyColumns     = []string{"id"}
	productCardsAttributeGeneratedColumns      = []string{"id"}
)

type (
	// ProductCardsAttributeSlice is an alias for a slice of pointers to ProductCardsAttribute.
	// This should almost always be used instead of []ProductCardsAttribute.
	ProductCardsAttributeSlice []*ProductCardsAttribute
	// ProductCardsAttributeHook is the signature for custom ProductCardsAttribute hook methods
	ProductCardsAttributeHook func(context.Context, boil.ContextExecutor, *ProductCardsAttribute) error

	productCardsAttributeQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	productCardsAttributeType                 = reflect.TypeOf(&ProductCardsAttribute{})
	productCardsAttributeMapping              = queries.MakeStructMapping(productCardsAttributeType)
	productCardsAttributePrimaryKeyMapping, _ = queries.BindMapping(productCardsAttributeType, productCardsAttributeMapping, productCardsAttributePrimaryKeyColumns)
	productCardsAttributeInsertCacheMut       sync.RWMutex
	productCardsAttributeInsertCache          = make(map[string]insertCache)
	productCardsAttributeUpdateCacheMut       sync.RWMutex
	productCardsAttributeUpdateCache          = make(map[string]updateCache)
	productCardsAttributeUpsertCacheMut       sync.RWMutex
	productCardsAttributeUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var productCardsAttributeAfterSelectMu sync.Mutex
var productCardsAttributeAfterSelectHooks []ProductCardsAttributeHook

var productCardsAttributeBeforeInsertMu sync.Mutex
var productCardsAttributeBeforeInsertHooks []ProductCardsAttributeHook
var productCardsAttributeAfterInsertMu sync.Mutex
var productCardsAttributeAfterInsertHooks []ProductCardsAttributeHook

var productCardsAttributeBeforeUpdateMu sync.Mutex
var productCardsAttributeBeforeUpdateHooks []ProductCardsAttributeHook
var productCardsAttributeAfterUpdateMu sync.Mutex
var productCardsAttributeAfterUpdateHooks []ProductCardsAttributeHook

var productCardsAttributeBeforeDeleteMu sync.Mutex
var productCardsAttributeBeforeDeleteHooks []ProductCardsAttributeHook
var productCardsAttributeAfterDeleteMu sync.Mutex
var productCardsAttributeAfterDeleteHooks []ProductCardsAttributeHook

var productCardsAttributeBeforeUpsertMu sync.Mutex
var productCardsAttributeBeforeUpsertHooks []ProductCardsAttributeHook
var productCardsAttributeAfterUpsertMu sync.Mutex
var productCardsAttributeAfterUpsertHooks []ProductCardsAttributeHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *ProductCardsAttribute) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range productCardsAttributeAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *ProductCardsAttribute) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range productCardsAttributeBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *ProductCardsAttribute) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range productCardsAttributeAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *ProductCardsAttribute) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range productCardsAttributeBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *ProductCardsAttribute) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range productCardsAttributeAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *ProductCardsAttribute) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range productCardsAttributeBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *ProductCardsAttribute) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range productCardsAttributeAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *ProductCardsAttribute) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range productCardsAttributeBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *ProductCardsAttribute) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range productCardsAttributeAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddProductCardsAttributeHook registers your hook function for all future operations.
func AddProductCardsAttributeHook(hookPoint boil.HookPoint, productCardsAttributeHook ProductCardsAttributeHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		productCardsAttributeAfterSelectMu.Lock()
		productCardsAttributeAfterSelectHooks = append(productCardsAttributeAfterSelectHooks, productCardsAttributeHook)
		productCardsAttributeAfterSelectMu.Unlock()
	case boil.BeforeInsertHook:
		productCardsAttributeBeforeInsertMu.Lock()
		productCardsAttributeBeforeInsertHooks = append(productCardsAttributeBeforeInsertHooks, productCardsAttributeHook)
		productCardsAttributeBeforeInsertMu.Unlock()
	case boil.AfterInsertHook:
		productCardsAttributeAfterInsertMu.Lock()
		productCardsAttributeAfterInsertHooks = append(productCardsAttributeAfterInsertHooks, productCardsAttributeHook)
		productCardsAttributeAfterInsertMu.Unlock()
	case boil.BeforeUpdateHook:
		productCardsAttributeBeforeUpdateMu.Lock()
		productCardsAttributeBeforeUpdateHooks = append(productCardsAttributeBeforeUpdateHooks, productCardsAttributeHook)
		productCardsAttributeBeforeUpdateMu.Unlock()
	case boil.AfterUpdateHook:
		productCardsAttributeAfterUpdateMu.Lock()
		productCardsAttributeAfterUpdateHooks = append(productCardsAttributeAfterUpdateHooks, productCardsAttributeHook)
		productCardsAttributeAfterUpdateMu.Unlock()
	case boil.BeforeDeleteHook:
		productCardsAttributeBeforeDeleteMu.Lock()
		productCardsAttributeBeforeDeleteHooks = append(productCardsAttributeBeforeDeleteHooks, productCardsAttributeHook)
		productCardsAttributeBeforeDeleteMu.Unlock()
	case boil.AfterDeleteHook:
		productCardsAttributeAfterDeleteMu.Lock()
		productCardsAttributeAfterDeleteHooks = append(productCardsAttributeAfterDeleteHooks, productCardsAttributeHook)
		productCardsAttributeAfterDeleteMu.Unlock()
	case boil.BeforeUpsertHook:
		productCardsAttributeBeforeUpsertMu.Lock()
		productCardsAttributeBeforeUpsertHooks = append(productCardsAttributeBeforeUpsertHooks, productCardsAttributeHook)
		productCardsAttributeBeforeUpsertMu.Unlock()
	case boil.AfterUpsertHook:
		productCardsAttributeAfterUpsertMu.Lock()
		productCardsAttributeAfterUpsertHooks = append(productCardsAttributeAfterUpsertHooks, productCardsAttributeHook)
		productCardsAttributeAfterUpsertMu.Unlock()
	}
}

// OneG returns a single productCardsAttribute record from the query using the global executor.
func (q productCardsAttributeQuery) OneG(ctx context.Context) (*ProductCardsAttribute, error) {
	return q.One(ctx, boil.GetContextDB())
}

// One returns a single productCardsAttribute record from the query.
func (q productCardsAttributeQuery) One(ctx context.Context, exec boil.ContextExecutor) (*ProductCardsAttribute, error) {
	o := &ProductCardsAttribute{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "znakboil: failed to execute a one query for product_cards_attributes")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// AllG returns all ProductCardsAttribute records from the query using the global executor.
func (q productCardsAttributeQuery) AllG(ctx context.Context) (ProductCardsAttributeSlice, error) {
	return q.All(ctx, boil.GetContextDB())
}

// All returns all ProductCardsAttribute records from the query.
func (q productCardsAttributeQuery) All(ctx context.Context, exec boil.ContextExecutor) (ProductCardsAttributeSlice, error) {
	var o []*ProductCardsAttribute

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "znakboil: failed to assign all query results to ProductCardsAttribute slice")
	}

	if len(productCardsAttributeAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// CountG returns the count of all ProductCardsAttribute records in the query using the global executor
func (q productCardsAttributeQuery) CountG(ctx context.Context) (int64, error) {
	return q.Count(ctx, boil.GetContextDB())
}

// Count returns the count of all ProductCardsAttribute records in the query.
func (q productCardsAttributeQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "znakboil: failed to count product_cards_attributes rows")
	}

	return count, nil
}

// ExistsG checks if the row exists in the table using the global executor.
func (q productCardsAttributeQuery) ExistsG(ctx context.Context) (bool, error) {
	return q.Exists(ctx, boil.GetContextDB())
}

// Exists checks if the row exists in the table.
func (q productCardsAttributeQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "znakboil: failed to check if product_cards_attributes exists")
	}

	return count > 0, nil
}

// ProductCardsAttributes retrieves all the records using an executor.
func ProductCardsAttributes(mods ...qm.QueryMod) productCardsAttributeQuery {
	mods = append(mods, qm.From("[dbo].[product_cards_attributes]"))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"[dbo].[product_cards_attributes].*"})
	}

	return productCardsAttributeQuery{q}
}

// FindProductCardsAttributeG retrieves a single record by ID.
func FindProductCardsAttributeG(ctx context.Context, iD int, selectCols ...string) (*ProductCardsAttribute, error) {
	return FindProductCardsAttribute(ctx, boil.GetContextDB(), iD, selectCols...)
}

// FindProductCardsAttribute retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindProductCardsAttribute(ctx context.Context, exec boil.ContextExecutor, iD int, selectCols ...string) (*ProductCardsAttribute, error) {
	productCardsAttributeObj := &ProductCardsAttribute{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from [dbo].[product_cards_attributes] where [id]=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, productCardsAttributeObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "znakboil: unable to select from product_cards_attributes")
	}

	if err = productCardsAttributeObj.doAfterSelectHooks(ctx, exec); err != nil {
		return productCardsAttributeObj, err
	}

	return productCardsAttributeObj, nil
}

// InsertG a single record. See Insert for whitelist behavior description.
func (o *ProductCardsAttribute) InsertG(ctx context.Context, columns boil.Columns) error {
	return o.Insert(ctx, boil.GetContextDB(), columns)
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *ProductCardsAttribute) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("znakboil: no product_cards_attributes provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(productCardsAttributeColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	productCardsAttributeInsertCacheMut.RLock()
	cache, cached := productCardsAttributeInsertCache[key]
	productCardsAttributeInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			productCardsAttributeAllColumns,
			productCardsAttributeColumnsWithDefault,
			productCardsAttributeColumnsWithoutDefault,
			nzDefaults,
		)
		wl = strmangle.SetComplement(wl, productCardsAttributeGeneratedColumns)

		cache.valueMapping, err = queries.BindMapping(productCardsAttributeType, productCardsAttributeMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(productCardsAttributeType, productCardsAttributeMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO [dbo].[product_cards_attributes] ([%s]) %%sVALUES (%s)%%s", strings.Join(wl, "],["), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO [dbo].[product_cards_attributes] %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryOutput = fmt.Sprintf("OUTPUT INSERTED.[%s] ", strings.Join(returnColumns, "],INSERTED.["))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "znakboil: unable to insert into product_cards_attributes")
	}

	if !cached {
		productCardsAttributeInsertCacheMut.Lock()
		productCardsAttributeInsertCache[key] = cache
		productCardsAttributeInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// UpdateG a single ProductCardsAttribute record using the global executor.
// See Update for more documentation.
func (o *ProductCardsAttribute) UpdateG(ctx context.Context, columns boil.Columns) (int64, error) {
	return o.Update(ctx, boil.GetContextDB(), columns)
}

// Update uses an executor to update the ProductCardsAttribute.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *ProductCardsAttribute) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	productCardsAttributeUpdateCacheMut.RLock()
	cache, cached := productCardsAttributeUpdateCache[key]
	productCardsAttributeUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			productCardsAttributeAllColumns,
			productCardsAttributePrimaryKeyColumns,
		)
		wl = strmangle.SetComplement(wl, productCardsAttributeGeneratedColumns)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("znakboil: unable to update product_cards_attributes, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE [dbo].[product_cards_attributes] SET %s WHERE %s",
			strmangle.SetParamNames("[", "]", 1, wl),
			strmangle.WhereClause("[", "]", len(wl)+1, productCardsAttributePrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(productCardsAttributeType, productCardsAttributeMapping, append(wl, productCardsAttributePrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "znakboil: unable to update product_cards_attributes row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "znakboil: failed to get rows affected by update for product_cards_attributes")
	}

	if !cached {
		productCardsAttributeUpdateCacheMut.Lock()
		productCardsAttributeUpdateCache[key] = cache
		productCardsAttributeUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAllG updates all rows with the specified column values.
func (q productCardsAttributeQuery) UpdateAllG(ctx context.Context, cols M) (int64, error) {
	return q.UpdateAll(ctx, boil.GetContextDB(), cols)
}

// UpdateAll updates all rows with the specified column values.
func (q productCardsAttributeQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "znakboil: unable to update all for product_cards_attributes")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "znakboil: unable to retrieve rows affected for product_cards_attributes")
	}

	return rowsAff, nil
}

// UpdateAllG updates all rows with the specified column values.
func (o ProductCardsAttributeSlice) UpdateAllG(ctx context.Context, cols M) (int64, error) {
	return o.UpdateAll(ctx, boil.GetContextDB(), cols)
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o ProductCardsAttributeSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("znakboil: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), productCardsAttributePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE [dbo].[product_cards_attributes] SET %s WHERE %s",
		strmangle.SetParamNames("[", "]", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, productCardsAttributePrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "znakboil: unable to update all in productCardsAttribute slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "znakboil: unable to retrieve rows affected all in update all productCardsAttribute")
	}
	return rowsAff, nil
}

// UpsertG attempts an insert, and does an update or ignore on conflict.
func (o *ProductCardsAttribute) UpsertG(ctx context.Context, updateColumns, insertColumns boil.Columns) error {
	return o.Upsert(ctx, boil.GetContextDB(), updateColumns, insertColumns)
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
func (o *ProductCardsAttribute) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("znakboil: no product_cards_attributes provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(productCardsAttributeColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	productCardsAttributeUpsertCacheMut.RLock()
	cache, cached := productCardsAttributeUpsertCache[key]
	productCardsAttributeUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			productCardsAttributeAllColumns,
			productCardsAttributeColumnsWithDefault,
			productCardsAttributeColumnsWithoutDefault,
			nzDefaults,
		)

		insert = strmangle.SetComplement(insert, productCardsAttributeGeneratedColumns)

		for i, v := range insert {
			if strmangle.ContainsAny(productCardsAttributePrimaryKeyColumns, v) && strmangle.ContainsAny(productCardsAttributeColumnsWithDefault, v) {
				insert = append(insert[:i], insert[i+1:]...)
			}
		}
		if len(insert) == 0 {
			return errors.New("znakboil: unable to upsert product_cards_attributes, could not build insert column list")
		}

		update := updateColumns.UpdateColumnSet(
			productCardsAttributeAllColumns,
			productCardsAttributePrimaryKeyColumns,
		)

		insert = strmangle.SetComplement(insert, productCardsAttributeGeneratedColumns)

		ret := strmangle.SetComplement(productCardsAttributeAllColumns, strmangle.SetIntersect(insert, update))

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("znakboil: unable to upsert product_cards_attributes, could not build update column list")
		}

		cache.query = buildUpsertQueryMSSQL(dialect, "[dbo].[product_cards_attributes]", productCardsAttributePrimaryKeyColumns, update, insert, ret)

		whitelist := make([]string, len(productCardsAttributePrimaryKeyColumns))
		copy(whitelist, productCardsAttributePrimaryKeyColumns)
		whitelist = append(whitelist, update...)
		whitelist = append(whitelist, insert...)

		cache.valueMapping, err = queries.BindMapping(productCardsAttributeType, productCardsAttributeMapping, whitelist)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(productCardsAttributeType, productCardsAttributeMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // MSSQL doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "znakboil: unable to upsert product_cards_attributes")
	}

	if !cached {
		productCardsAttributeUpsertCacheMut.Lock()
		productCardsAttributeUpsertCache[key] = cache
		productCardsAttributeUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// DeleteG deletes a single ProductCardsAttribute record.
// DeleteG will match against the primary key column to find the record to delete.
func (o *ProductCardsAttribute) DeleteG(ctx context.Context) (int64, error) {
	return o.Delete(ctx, boil.GetContextDB())
}

// Delete deletes a single ProductCardsAttribute record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *ProductCardsAttribute) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("znakboil: no ProductCardsAttribute provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), productCardsAttributePrimaryKeyMapping)
	sql := "DELETE FROM [dbo].[product_cards_attributes] WHERE [id]=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "znakboil: unable to delete from product_cards_attributes")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "znakboil: failed to get rows affected by delete for product_cards_attributes")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

func (q productCardsAttributeQuery) DeleteAllG(ctx context.Context) (int64, error) {
	return q.DeleteAll(ctx, boil.GetContextDB())
}

// DeleteAll deletes all matching rows.
func (q productCardsAttributeQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("znakboil: no productCardsAttributeQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "znakboil: unable to delete all from product_cards_attributes")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "znakboil: failed to get rows affected by deleteall for product_cards_attributes")
	}

	return rowsAff, nil
}

// DeleteAllG deletes all rows in the slice.
func (o ProductCardsAttributeSlice) DeleteAllG(ctx context.Context) (int64, error) {
	return o.DeleteAll(ctx, boil.GetContextDB())
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o ProductCardsAttributeSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(productCardsAttributeBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), productCardsAttributePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM [dbo].[product_cards_attributes] WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, productCardsAttributePrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "znakboil: unable to delete all from productCardsAttribute slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "znakboil: failed to get rows affected by deleteall for product_cards_attributes")
	}

	if len(productCardsAttributeAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// ReloadG refetches the object from the database using the primary keys.
func (o *ProductCardsAttribute) ReloadG(ctx context.Context) error {
	if o == nil {
		return errors.New("znakboil: no ProductCardsAttribute provided for reload")
	}

	return o.Reload(ctx, boil.GetContextDB())
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *ProductCardsAttribute) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindProductCardsAttribute(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAllG refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *ProductCardsAttributeSlice) ReloadAllG(ctx context.Context) error {
	if o == nil {
		return errors.New("znakboil: empty ProductCardsAttributeSlice provided for reload all")
	}

	return o.ReloadAll(ctx, boil.GetContextDB())
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *ProductCardsAttributeSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := ProductCardsAttributeSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), productCardsAttributePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT [dbo].[product_cards_attributes].* FROM [dbo].[product_cards_attributes] WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, productCardsAttributePrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "znakboil: unable to reload all in ProductCardsAttributeSlice")
	}

	*o = slice

	return nil
}

// ProductCardsAttributeExistsG checks if the ProductCardsAttribute row exists.
func ProductCardsAttributeExistsG(ctx context.Context, iD int) (bool, error) {
	return ProductCardsAttributeExists(ctx, boil.GetContextDB(), iD)
}

// ProductCardsAttributeExists checks if the ProductCardsAttribute row exists.
func ProductCardsAttributeExists(ctx context.Context, exec boil.ContextExecutor, iD int) (bool, error) {
	var exists bool
	sql := "select case when exists(select top(1) 1 from [dbo].[product_cards_attributes] where [id]=$1) then 1 else 0 end"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "znakboil: unable to check if product_cards_attributes exists")
	}

	return exists, nil
}

// Exists checks if the ProductCardsAttribute row exists.
func (o *ProductCardsAttribute) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return ProductCardsAttributeExists(ctx, exec, o.ID)
}
