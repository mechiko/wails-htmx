// Code generated by SQLBoiler 4.16.2 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package a3boil

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// Form1Egais is an object representing the database table.
type Form1Egais struct {
	ID                   int64       `boil:"id" json:"id" toml:"id" yaml:"id"`
	IDRequests           null.Int64  `boil:"id_requests" json:"id_requests,omitempty" toml:"id_requests" yaml:"id_requests,omitempty"`
	OriginalDocNumber    null.String `boil:"original_doc_number" json:"original_doc_number,omitempty" toml:"original_doc_number" yaml:"original_doc_number,omitempty"`
	OriginalDocDate      null.String `boil:"original_doc_date" json:"original_doc_date,omitempty" toml:"original_doc_date" yaml:"original_doc_date,omitempty"`
	BottlingDate         null.String `boil:"bottling_date" json:"bottling_date,omitempty" toml:"bottling_date" yaml:"bottling_date,omitempty"`
	EgaisNumber          null.String `boil:"egais_number" json:"egais_number,omitempty" toml:"egais_number" yaml:"egais_number,omitempty"`
	EgaisDate            null.String `boil:"egais_date" json:"egais_date,omitempty" toml:"egais_date" yaml:"egais_date,omitempty"`
	GTDNumber            null.String `boil:"gtd_number" json:"gtd_number,omitempty" toml:"gtd_number" yaml:"gtd_number,omitempty"`
	GTDDate              null.String `boil:"gtd_date" json:"gtd_date,omitempty" toml:"gtd_date" yaml:"gtd_date,omitempty"`
	ClientType           null.String `boil:"client_type" json:"client_type,omitempty" toml:"client_type" yaml:"client_type,omitempty"`
	ClientRegID          null.String `boil:"client_reg_id" json:"client_reg_id,omitempty" toml:"client_reg_id" yaml:"client_reg_id,omitempty"`
	ClientInn            null.String `boil:"client_inn" json:"client_inn,omitempty" toml:"client_inn" yaml:"client_inn,omitempty"`
	ClientKPP            null.String `boil:"client_kpp" json:"client_kpp,omitempty" toml:"client_kpp" yaml:"client_kpp,omitempty"`
	ClientFullName       null.String `boil:"client_full_name" json:"client_full_name,omitempty" toml:"client_full_name" yaml:"client_full_name,omitempty"`
	ClientShortName      null.String `boil:"client_short_name" json:"client_short_name,omitempty" toml:"client_short_name" yaml:"client_short_name,omitempty"`
	ClientCountryCode    null.String `boil:"client_country_code" json:"client_country_code,omitempty" toml:"client_country_code" yaml:"client_country_code,omitempty"`
	ClientRegionCode     null.String `boil:"client_region_code" json:"client_region_code,omitempty" toml:"client_region_code" yaml:"client_region_code,omitempty"`
	ClientDescription    null.String `boil:"client_description" json:"client_description,omitempty" toml:"client_description" yaml:"client_description,omitempty"`
	ProductFullName      null.String `boil:"product_full_name" json:"product_full_name,omitempty" toml:"product_full_name" yaml:"product_full_name,omitempty"`
	ProductCapacity      null.String `boil:"product_capacity" json:"product_capacity,omitempty" toml:"product_capacity" yaml:"product_capacity,omitempty"`
	ProductAlcVolume     null.String `boil:"product_alc_volume" json:"product_alc_volume,omitempty" toml:"product_alc_volume" yaml:"product_alc_volume,omitempty"`
	ProductAlcCode       null.String `boil:"product_alc_code" json:"product_alc_code,omitempty" toml:"product_alc_code" yaml:"product_alc_code,omitempty"`
	ProductCode          null.String `boil:"product_code" json:"product_code,omitempty" toml:"product_code" yaml:"product_code,omitempty"`
	ProductUnitType      null.String `boil:"product_unit_type" json:"product_unit_type,omitempty" toml:"product_unit_type" yaml:"product_unit_type,omitempty"`
	ProductQuantity      null.String `boil:"product_quantity" json:"product_quantity,omitempty" toml:"product_quantity" yaml:"product_quantity,omitempty"`
	ProductInformF1RegID null.String `boil:"product_inform_f1_reg_id" json:"product_inform_f1_reg_id,omitempty" toml:"product_inform_f1_reg_id" yaml:"product_inform_f1_reg_id,omitempty"`
	ProducerType         null.String `boil:"producer_type" json:"producer_type,omitempty" toml:"producer_type" yaml:"producer_type,omitempty"`
	ProducerClientRegID  null.String `boil:"producer_client_reg_id" json:"producer_client_reg_id,omitempty" toml:"producer_client_reg_id" yaml:"producer_client_reg_id,omitempty"`
	ProducerInn          null.String `boil:"producer_inn" json:"producer_inn,omitempty" toml:"producer_inn" yaml:"producer_inn,omitempty"`
	ProducerKPP          null.String `boil:"producer_kpp" json:"producer_kpp,omitempty" toml:"producer_kpp" yaml:"producer_kpp,omitempty"`
	ProducerFullName     null.String `boil:"producer_full_name" json:"producer_full_name,omitempty" toml:"producer_full_name" yaml:"producer_full_name,omitempty"`
	ProducerShortName    null.String `boil:"producer_short_name" json:"producer_short_name,omitempty" toml:"producer_short_name" yaml:"producer_short_name,omitempty"`
	ProducerCountryCode  null.String `boil:"producer_country_code" json:"producer_country_code,omitempty" toml:"producer_country_code" yaml:"producer_country_code,omitempty"`
	ProducerRegionCode   null.String `boil:"producer_region_code" json:"producer_region_code,omitempty" toml:"producer_region_code" yaml:"producer_region_code,omitempty"`
	ProducerDescription  null.String `boil:"producer_description" json:"producer_description,omitempty" toml:"producer_description" yaml:"producer_description,omitempty"`

	R *form1EgaisR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L form1EgaisL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var Form1EgaisColumns = struct {
	ID                   string
	IDRequests           string
	OriginalDocNumber    string
	OriginalDocDate      string
	BottlingDate         string
	EgaisNumber          string
	EgaisDate            string
	GTDNumber            string
	GTDDate              string
	ClientType           string
	ClientRegID          string
	ClientInn            string
	ClientKPP            string
	ClientFullName       string
	ClientShortName      string
	ClientCountryCode    string
	ClientRegionCode     string
	ClientDescription    string
	ProductFullName      string
	ProductCapacity      string
	ProductAlcVolume     string
	ProductAlcCode       string
	ProductCode          string
	ProductUnitType      string
	ProductQuantity      string
	ProductInformF1RegID string
	ProducerType         string
	ProducerClientRegID  string
	ProducerInn          string
	ProducerKPP          string
	ProducerFullName     string
	ProducerShortName    string
	ProducerCountryCode  string
	ProducerRegionCode   string
	ProducerDescription  string
}{
	ID:                   "id",
	IDRequests:           "id_requests",
	OriginalDocNumber:    "original_doc_number",
	OriginalDocDate:      "original_doc_date",
	BottlingDate:         "bottling_date",
	EgaisNumber:          "egais_number",
	EgaisDate:            "egais_date",
	GTDNumber:            "gtd_number",
	GTDDate:              "gtd_date",
	ClientType:           "client_type",
	ClientRegID:          "client_reg_id",
	ClientInn:            "client_inn",
	ClientKPP:            "client_kpp",
	ClientFullName:       "client_full_name",
	ClientShortName:      "client_short_name",
	ClientCountryCode:    "client_country_code",
	ClientRegionCode:     "client_region_code",
	ClientDescription:    "client_description",
	ProductFullName:      "product_full_name",
	ProductCapacity:      "product_capacity",
	ProductAlcVolume:     "product_alc_volume",
	ProductAlcCode:       "product_alc_code",
	ProductCode:          "product_code",
	ProductUnitType:      "product_unit_type",
	ProductQuantity:      "product_quantity",
	ProductInformF1RegID: "product_inform_f1_reg_id",
	ProducerType:         "producer_type",
	ProducerClientRegID:  "producer_client_reg_id",
	ProducerInn:          "producer_inn",
	ProducerKPP:          "producer_kpp",
	ProducerFullName:     "producer_full_name",
	ProducerShortName:    "producer_short_name",
	ProducerCountryCode:  "producer_country_code",
	ProducerRegionCode:   "producer_region_code",
	ProducerDescription:  "producer_description",
}

var Form1EgaisTableColumns = struct {
	ID                   string
	IDRequests           string
	OriginalDocNumber    string
	OriginalDocDate      string
	BottlingDate         string
	EgaisNumber          string
	EgaisDate            string
	GTDNumber            string
	GTDDate              string
	ClientType           string
	ClientRegID          string
	ClientInn            string
	ClientKPP            string
	ClientFullName       string
	ClientShortName      string
	ClientCountryCode    string
	ClientRegionCode     string
	ClientDescription    string
	ProductFullName      string
	ProductCapacity      string
	ProductAlcVolume     string
	ProductAlcCode       string
	ProductCode          string
	ProductUnitType      string
	ProductQuantity      string
	ProductInformF1RegID string
	ProducerType         string
	ProducerClientRegID  string
	ProducerInn          string
	ProducerKPP          string
	ProducerFullName     string
	ProducerShortName    string
	ProducerCountryCode  string
	ProducerRegionCode   string
	ProducerDescription  string
}{
	ID:                   "form1_egais.id",
	IDRequests:           "form1_egais.id_requests",
	OriginalDocNumber:    "form1_egais.original_doc_number",
	OriginalDocDate:      "form1_egais.original_doc_date",
	BottlingDate:         "form1_egais.bottling_date",
	EgaisNumber:          "form1_egais.egais_number",
	EgaisDate:            "form1_egais.egais_date",
	GTDNumber:            "form1_egais.gtd_number",
	GTDDate:              "form1_egais.gtd_date",
	ClientType:           "form1_egais.client_type",
	ClientRegID:          "form1_egais.client_reg_id",
	ClientInn:            "form1_egais.client_inn",
	ClientKPP:            "form1_egais.client_kpp",
	ClientFullName:       "form1_egais.client_full_name",
	ClientShortName:      "form1_egais.client_short_name",
	ClientCountryCode:    "form1_egais.client_country_code",
	ClientRegionCode:     "form1_egais.client_region_code",
	ClientDescription:    "form1_egais.client_description",
	ProductFullName:      "form1_egais.product_full_name",
	ProductCapacity:      "form1_egais.product_capacity",
	ProductAlcVolume:     "form1_egais.product_alc_volume",
	ProductAlcCode:       "form1_egais.product_alc_code",
	ProductCode:          "form1_egais.product_code",
	ProductUnitType:      "form1_egais.product_unit_type",
	ProductQuantity:      "form1_egais.product_quantity",
	ProductInformF1RegID: "form1_egais.product_inform_f1_reg_id",
	ProducerType:         "form1_egais.producer_type",
	ProducerClientRegID:  "form1_egais.producer_client_reg_id",
	ProducerInn:          "form1_egais.producer_inn",
	ProducerKPP:          "form1_egais.producer_kpp",
	ProducerFullName:     "form1_egais.producer_full_name",
	ProducerShortName:    "form1_egais.producer_short_name",
	ProducerCountryCode:  "form1_egais.producer_country_code",
	ProducerRegionCode:   "form1_egais.producer_region_code",
	ProducerDescription:  "form1_egais.producer_description",
}

// Generated where

var Form1EgaisWhere = struct {
	ID                   whereHelperint64
	IDRequests           whereHelpernull_Int64
	OriginalDocNumber    whereHelpernull_String
	OriginalDocDate      whereHelpernull_String
	BottlingDate         whereHelpernull_String
	EgaisNumber          whereHelpernull_String
	EgaisDate            whereHelpernull_String
	GTDNumber            whereHelpernull_String
	GTDDate              whereHelpernull_String
	ClientType           whereHelpernull_String
	ClientRegID          whereHelpernull_String
	ClientInn            whereHelpernull_String
	ClientKPP            whereHelpernull_String
	ClientFullName       whereHelpernull_String
	ClientShortName      whereHelpernull_String
	ClientCountryCode    whereHelpernull_String
	ClientRegionCode     whereHelpernull_String
	ClientDescription    whereHelpernull_String
	ProductFullName      whereHelpernull_String
	ProductCapacity      whereHelpernull_String
	ProductAlcVolume     whereHelpernull_String
	ProductAlcCode       whereHelpernull_String
	ProductCode          whereHelpernull_String
	ProductUnitType      whereHelpernull_String
	ProductQuantity      whereHelpernull_String
	ProductInformF1RegID whereHelpernull_String
	ProducerType         whereHelpernull_String
	ProducerClientRegID  whereHelpernull_String
	ProducerInn          whereHelpernull_String
	ProducerKPP          whereHelpernull_String
	ProducerFullName     whereHelpernull_String
	ProducerShortName    whereHelpernull_String
	ProducerCountryCode  whereHelpernull_String
	ProducerRegionCode   whereHelpernull_String
	ProducerDescription  whereHelpernull_String
}{
	ID:                   whereHelperint64{field: "\"form1_egais\".\"id\""},
	IDRequests:           whereHelpernull_Int64{field: "\"form1_egais\".\"id_requests\""},
	OriginalDocNumber:    whereHelpernull_String{field: "\"form1_egais\".\"original_doc_number\""},
	OriginalDocDate:      whereHelpernull_String{field: "\"form1_egais\".\"original_doc_date\""},
	BottlingDate:         whereHelpernull_String{field: "\"form1_egais\".\"bottling_date\""},
	EgaisNumber:          whereHelpernull_String{field: "\"form1_egais\".\"egais_number\""},
	EgaisDate:            whereHelpernull_String{field: "\"form1_egais\".\"egais_date\""},
	GTDNumber:            whereHelpernull_String{field: "\"form1_egais\".\"gtd_number\""},
	GTDDate:              whereHelpernull_String{field: "\"form1_egais\".\"gtd_date\""},
	ClientType:           whereHelpernull_String{field: "\"form1_egais\".\"client_type\""},
	ClientRegID:          whereHelpernull_String{field: "\"form1_egais\".\"client_reg_id\""},
	ClientInn:            whereHelpernull_String{field: "\"form1_egais\".\"client_inn\""},
	ClientKPP:            whereHelpernull_String{field: "\"form1_egais\".\"client_kpp\""},
	ClientFullName:       whereHelpernull_String{field: "\"form1_egais\".\"client_full_name\""},
	ClientShortName:      whereHelpernull_String{field: "\"form1_egais\".\"client_short_name\""},
	ClientCountryCode:    whereHelpernull_String{field: "\"form1_egais\".\"client_country_code\""},
	ClientRegionCode:     whereHelpernull_String{field: "\"form1_egais\".\"client_region_code\""},
	ClientDescription:    whereHelpernull_String{field: "\"form1_egais\".\"client_description\""},
	ProductFullName:      whereHelpernull_String{field: "\"form1_egais\".\"product_full_name\""},
	ProductCapacity:      whereHelpernull_String{field: "\"form1_egais\".\"product_capacity\""},
	ProductAlcVolume:     whereHelpernull_String{field: "\"form1_egais\".\"product_alc_volume\""},
	ProductAlcCode:       whereHelpernull_String{field: "\"form1_egais\".\"product_alc_code\""},
	ProductCode:          whereHelpernull_String{field: "\"form1_egais\".\"product_code\""},
	ProductUnitType:      whereHelpernull_String{field: "\"form1_egais\".\"product_unit_type\""},
	ProductQuantity:      whereHelpernull_String{field: "\"form1_egais\".\"product_quantity\""},
	ProductInformF1RegID: whereHelpernull_String{field: "\"form1_egais\".\"product_inform_f1_reg_id\""},
	ProducerType:         whereHelpernull_String{field: "\"form1_egais\".\"producer_type\""},
	ProducerClientRegID:  whereHelpernull_String{field: "\"form1_egais\".\"producer_client_reg_id\""},
	ProducerInn:          whereHelpernull_String{field: "\"form1_egais\".\"producer_inn\""},
	ProducerKPP:          whereHelpernull_String{field: "\"form1_egais\".\"producer_kpp\""},
	ProducerFullName:     whereHelpernull_String{field: "\"form1_egais\".\"producer_full_name\""},
	ProducerShortName:    whereHelpernull_String{field: "\"form1_egais\".\"producer_short_name\""},
	ProducerCountryCode:  whereHelpernull_String{field: "\"form1_egais\".\"producer_country_code\""},
	ProducerRegionCode:   whereHelpernull_String{field: "\"form1_egais\".\"producer_region_code\""},
	ProducerDescription:  whereHelpernull_String{field: "\"form1_egais\".\"producer_description\""},
}

// Form1EgaisRels is where relationship names are stored.
var Form1EgaisRels = struct {
}{}

// form1EgaisR is where relationships are stored.
type form1EgaisR struct {
}

// NewStruct creates a new relationship struct
func (*form1EgaisR) NewStruct() *form1EgaisR {
	return &form1EgaisR{}
}

// form1EgaisL is where Load methods for each relationship are stored.
type form1EgaisL struct{}

var (
	form1EgaisAllColumns            = []string{"id", "id_requests", "original_doc_number", "original_doc_date", "bottling_date", "egais_number", "egais_date", "gtd_number", "gtd_date", "client_type", "client_reg_id", "client_inn", "client_kpp", "client_full_name", "client_short_name", "client_country_code", "client_region_code", "client_description", "product_full_name", "product_capacity", "product_alc_volume", "product_alc_code", "product_code", "product_unit_type", "product_quantity", "product_inform_f1_reg_id", "producer_type", "producer_client_reg_id", "producer_inn", "producer_kpp", "producer_full_name", "producer_short_name", "producer_country_code", "producer_region_code", "producer_description"}
	form1EgaisColumnsWithoutDefault = []string{}
	form1EgaisColumnsWithDefault    = []string{"id", "id_requests", "original_doc_number", "original_doc_date", "bottling_date", "egais_number", "egais_date", "gtd_number", "gtd_date", "client_type", "client_reg_id", "client_inn", "client_kpp", "client_full_name", "client_short_name", "client_country_code", "client_region_code", "client_description", "product_full_name", "product_capacity", "product_alc_volume", "product_alc_code", "product_code", "product_unit_type", "product_quantity", "product_inform_f1_reg_id", "producer_type", "producer_client_reg_id", "producer_inn", "producer_kpp", "producer_full_name", "producer_short_name", "producer_country_code", "producer_region_code", "producer_description"}
	form1EgaisPrimaryKeyColumns     = []string{"id"}
	form1EgaisGeneratedColumns      = []string{"id"}
)

type (
	// Form1EgaisSlice is an alias for a slice of pointers to Form1Egais.
	// This should almost always be used instead of []Form1Egais.
	Form1EgaisSlice []*Form1Egais
	// Form1EgaisHook is the signature for custom Form1Egais hook methods
	Form1EgaisHook func(context.Context, boil.ContextExecutor, *Form1Egais) error

	form1EgaisQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	form1EgaisType                 = reflect.TypeOf(&Form1Egais{})
	form1EgaisMapping              = queries.MakeStructMapping(form1EgaisType)
	form1EgaisPrimaryKeyMapping, _ = queries.BindMapping(form1EgaisType, form1EgaisMapping, form1EgaisPrimaryKeyColumns)
	form1EgaisInsertCacheMut       sync.RWMutex
	form1EgaisInsertCache          = make(map[string]insertCache)
	form1EgaisUpdateCacheMut       sync.RWMutex
	form1EgaisUpdateCache          = make(map[string]updateCache)
	form1EgaisUpsertCacheMut       sync.RWMutex
	form1EgaisUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var form1EgaisAfterSelectMu sync.Mutex
var form1EgaisAfterSelectHooks []Form1EgaisHook

var form1EgaisBeforeInsertMu sync.Mutex
var form1EgaisBeforeInsertHooks []Form1EgaisHook
var form1EgaisAfterInsertMu sync.Mutex
var form1EgaisAfterInsertHooks []Form1EgaisHook

var form1EgaisBeforeUpdateMu sync.Mutex
var form1EgaisBeforeUpdateHooks []Form1EgaisHook
var form1EgaisAfterUpdateMu sync.Mutex
var form1EgaisAfterUpdateHooks []Form1EgaisHook

var form1EgaisBeforeDeleteMu sync.Mutex
var form1EgaisBeforeDeleteHooks []Form1EgaisHook
var form1EgaisAfterDeleteMu sync.Mutex
var form1EgaisAfterDeleteHooks []Form1EgaisHook

var form1EgaisBeforeUpsertMu sync.Mutex
var form1EgaisBeforeUpsertHooks []Form1EgaisHook
var form1EgaisAfterUpsertMu sync.Mutex
var form1EgaisAfterUpsertHooks []Form1EgaisHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Form1Egais) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range form1EgaisAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Form1Egais) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range form1EgaisBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Form1Egais) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range form1EgaisAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Form1Egais) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range form1EgaisBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Form1Egais) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range form1EgaisAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Form1Egais) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range form1EgaisBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Form1Egais) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range form1EgaisAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Form1Egais) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range form1EgaisBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Form1Egais) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range form1EgaisAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddForm1EgaisHook registers your hook function for all future operations.
func AddForm1EgaisHook(hookPoint boil.HookPoint, form1EgaisHook Form1EgaisHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		form1EgaisAfterSelectMu.Lock()
		form1EgaisAfterSelectHooks = append(form1EgaisAfterSelectHooks, form1EgaisHook)
		form1EgaisAfterSelectMu.Unlock()
	case boil.BeforeInsertHook:
		form1EgaisBeforeInsertMu.Lock()
		form1EgaisBeforeInsertHooks = append(form1EgaisBeforeInsertHooks, form1EgaisHook)
		form1EgaisBeforeInsertMu.Unlock()
	case boil.AfterInsertHook:
		form1EgaisAfterInsertMu.Lock()
		form1EgaisAfterInsertHooks = append(form1EgaisAfterInsertHooks, form1EgaisHook)
		form1EgaisAfterInsertMu.Unlock()
	case boil.BeforeUpdateHook:
		form1EgaisBeforeUpdateMu.Lock()
		form1EgaisBeforeUpdateHooks = append(form1EgaisBeforeUpdateHooks, form1EgaisHook)
		form1EgaisBeforeUpdateMu.Unlock()
	case boil.AfterUpdateHook:
		form1EgaisAfterUpdateMu.Lock()
		form1EgaisAfterUpdateHooks = append(form1EgaisAfterUpdateHooks, form1EgaisHook)
		form1EgaisAfterUpdateMu.Unlock()
	case boil.BeforeDeleteHook:
		form1EgaisBeforeDeleteMu.Lock()
		form1EgaisBeforeDeleteHooks = append(form1EgaisBeforeDeleteHooks, form1EgaisHook)
		form1EgaisBeforeDeleteMu.Unlock()
	case boil.AfterDeleteHook:
		form1EgaisAfterDeleteMu.Lock()
		form1EgaisAfterDeleteHooks = append(form1EgaisAfterDeleteHooks, form1EgaisHook)
		form1EgaisAfterDeleteMu.Unlock()
	case boil.BeforeUpsertHook:
		form1EgaisBeforeUpsertMu.Lock()
		form1EgaisBeforeUpsertHooks = append(form1EgaisBeforeUpsertHooks, form1EgaisHook)
		form1EgaisBeforeUpsertMu.Unlock()
	case boil.AfterUpsertHook:
		form1EgaisAfterUpsertMu.Lock()
		form1EgaisAfterUpsertHooks = append(form1EgaisAfterUpsertHooks, form1EgaisHook)
		form1EgaisAfterUpsertMu.Unlock()
	}
}

// OneG returns a single form1Egais record from the query using the global executor.
func (q form1EgaisQuery) OneG(ctx context.Context) (*Form1Egais, error) {
	return q.One(ctx, boil.GetContextDB())
}

// One returns a single form1Egais record from the query.
func (q form1EgaisQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Form1Egais, error) {
	o := &Form1Egais{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "a3boil: failed to execute a one query for form1_egais")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// AllG returns all Form1Egais records from the query using the global executor.
func (q form1EgaisQuery) AllG(ctx context.Context) (Form1EgaisSlice, error) {
	return q.All(ctx, boil.GetContextDB())
}

// All returns all Form1Egais records from the query.
func (q form1EgaisQuery) All(ctx context.Context, exec boil.ContextExecutor) (Form1EgaisSlice, error) {
	var o []*Form1Egais

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "a3boil: failed to assign all query results to Form1Egais slice")
	}

	if len(form1EgaisAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// CountG returns the count of all Form1Egais records in the query using the global executor
func (q form1EgaisQuery) CountG(ctx context.Context) (int64, error) {
	return q.Count(ctx, boil.GetContextDB())
}

// Count returns the count of all Form1Egais records in the query.
func (q form1EgaisQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "a3boil: failed to count form1_egais rows")
	}

	return count, nil
}

// ExistsG checks if the row exists in the table using the global executor.
func (q form1EgaisQuery) ExistsG(ctx context.Context) (bool, error) {
	return q.Exists(ctx, boil.GetContextDB())
}

// Exists checks if the row exists in the table.
func (q form1EgaisQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "a3boil: failed to check if form1_egais exists")
	}

	return count > 0, nil
}

// Form1Egaiss retrieves all the records using an executor.
func Form1Egaiss(mods ...qm.QueryMod) form1EgaisQuery {
	mods = append(mods, qm.From("\"form1_egais\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"form1_egais\".*"})
	}

	return form1EgaisQuery{q}
}

// FindForm1EgaisG retrieves a single record by ID.
func FindForm1EgaisG(ctx context.Context, iD int64, selectCols ...string) (*Form1Egais, error) {
	return FindForm1Egais(ctx, boil.GetContextDB(), iD, selectCols...)
}

// FindForm1Egais retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindForm1Egais(ctx context.Context, exec boil.ContextExecutor, iD int64, selectCols ...string) (*Form1Egais, error) {
	form1EgaisObj := &Form1Egais{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"form1_egais\" where \"id\"=?", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, form1EgaisObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "a3boil: unable to select from form1_egais")
	}

	if err = form1EgaisObj.doAfterSelectHooks(ctx, exec); err != nil {
		return form1EgaisObj, err
	}

	return form1EgaisObj, nil
}

// InsertG a single record. See Insert for whitelist behavior description.
func (o *Form1Egais) InsertG(ctx context.Context, columns boil.Columns) error {
	return o.Insert(ctx, boil.GetContextDB(), columns)
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Form1Egais) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("a3boil: no form1_egais provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(form1EgaisColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	form1EgaisInsertCacheMut.RLock()
	cache, cached := form1EgaisInsertCache[key]
	form1EgaisInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			form1EgaisAllColumns,
			form1EgaisColumnsWithDefault,
			form1EgaisColumnsWithoutDefault,
			nzDefaults,
		)
		wl = strmangle.SetComplement(wl, form1EgaisGeneratedColumns)

		cache.valueMapping, err = queries.BindMapping(form1EgaisType, form1EgaisMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(form1EgaisType, form1EgaisMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"form1_egais\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"form1_egais\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "a3boil: unable to insert into form1_egais")
	}

	if !cached {
		form1EgaisInsertCacheMut.Lock()
		form1EgaisInsertCache[key] = cache
		form1EgaisInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// UpdateG a single Form1Egais record using the global executor.
// See Update for more documentation.
func (o *Form1Egais) UpdateG(ctx context.Context, columns boil.Columns) (int64, error) {
	return o.Update(ctx, boil.GetContextDB(), columns)
}

// Update uses an executor to update the Form1Egais.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Form1Egais) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	form1EgaisUpdateCacheMut.RLock()
	cache, cached := form1EgaisUpdateCache[key]
	form1EgaisUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			form1EgaisAllColumns,
			form1EgaisPrimaryKeyColumns,
		)
		wl = strmangle.SetComplement(wl, form1EgaisGeneratedColumns)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("a3boil: unable to update form1_egais, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"form1_egais\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 0, wl),
			strmangle.WhereClause("\"", "\"", 0, form1EgaisPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(form1EgaisType, form1EgaisMapping, append(wl, form1EgaisPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "a3boil: unable to update form1_egais row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "a3boil: failed to get rows affected by update for form1_egais")
	}

	if !cached {
		form1EgaisUpdateCacheMut.Lock()
		form1EgaisUpdateCache[key] = cache
		form1EgaisUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAllG updates all rows with the specified column values.
func (q form1EgaisQuery) UpdateAllG(ctx context.Context, cols M) (int64, error) {
	return q.UpdateAll(ctx, boil.GetContextDB(), cols)
}

// UpdateAll updates all rows with the specified column values.
func (q form1EgaisQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "a3boil: unable to update all for form1_egais")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "a3boil: unable to retrieve rows affected for form1_egais")
	}

	return rowsAff, nil
}

// UpdateAllG updates all rows with the specified column values.
func (o Form1EgaisSlice) UpdateAllG(ctx context.Context, cols M) (int64, error) {
	return o.UpdateAll(ctx, boil.GetContextDB(), cols)
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o Form1EgaisSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("a3boil: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), form1EgaisPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"form1_egais\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, form1EgaisPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "a3boil: unable to update all in form1Egais slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "a3boil: unable to retrieve rows affected all in update all form1Egais")
	}
	return rowsAff, nil
}

// UpsertG attempts an insert, and does an update or ignore on conflict.
func (o *Form1Egais) UpsertG(ctx context.Context, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	return o.Upsert(ctx, boil.GetContextDB(), updateOnConflict, conflictColumns, updateColumns, insertColumns)
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Form1Egais) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("a3boil: no form1_egais provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(form1EgaisColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	form1EgaisUpsertCacheMut.RLock()
	cache, cached := form1EgaisUpsertCache[key]
	form1EgaisUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			form1EgaisAllColumns,
			form1EgaisColumnsWithDefault,
			form1EgaisColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			form1EgaisAllColumns,
			form1EgaisPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("a3boil: unable to upsert form1_egais, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(form1EgaisPrimaryKeyColumns))
			copy(conflict, form1EgaisPrimaryKeyColumns)
		}
		cache.query = buildUpsertQuerySQLite(dialect, "\"form1_egais\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(form1EgaisType, form1EgaisMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(form1EgaisType, form1EgaisMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "a3boil: unable to upsert form1_egais")
	}

	if !cached {
		form1EgaisUpsertCacheMut.Lock()
		form1EgaisUpsertCache[key] = cache
		form1EgaisUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// DeleteG deletes a single Form1Egais record.
// DeleteG will match against the primary key column to find the record to delete.
func (o *Form1Egais) DeleteG(ctx context.Context) (int64, error) {
	return o.Delete(ctx, boil.GetContextDB())
}

// Delete deletes a single Form1Egais record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Form1Egais) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("a3boil: no Form1Egais provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), form1EgaisPrimaryKeyMapping)
	sql := "DELETE FROM \"form1_egais\" WHERE \"id\"=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "a3boil: unable to delete from form1_egais")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "a3boil: failed to get rows affected by delete for form1_egais")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

func (q form1EgaisQuery) DeleteAllG(ctx context.Context) (int64, error) {
	return q.DeleteAll(ctx, boil.GetContextDB())
}

// DeleteAll deletes all matching rows.
func (q form1EgaisQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("a3boil: no form1EgaisQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "a3boil: unable to delete all from form1_egais")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "a3boil: failed to get rows affected by deleteall for form1_egais")
	}

	return rowsAff, nil
}

// DeleteAllG deletes all rows in the slice.
func (o Form1EgaisSlice) DeleteAllG(ctx context.Context) (int64, error) {
	return o.DeleteAll(ctx, boil.GetContextDB())
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o Form1EgaisSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(form1EgaisBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), form1EgaisPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"form1_egais\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, form1EgaisPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "a3boil: unable to delete all from form1Egais slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "a3boil: failed to get rows affected by deleteall for form1_egais")
	}

	if len(form1EgaisAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// ReloadG refetches the object from the database using the primary keys.
func (o *Form1Egais) ReloadG(ctx context.Context) error {
	if o == nil {
		return errors.New("a3boil: no Form1Egais provided for reload")
	}

	return o.Reload(ctx, boil.GetContextDB())
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Form1Egais) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindForm1Egais(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAllG refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *Form1EgaisSlice) ReloadAllG(ctx context.Context) error {
	if o == nil {
		return errors.New("a3boil: empty Form1EgaisSlice provided for reload all")
	}

	return o.ReloadAll(ctx, boil.GetContextDB())
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *Form1EgaisSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := Form1EgaisSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), form1EgaisPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"form1_egais\".* FROM \"form1_egais\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, form1EgaisPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "a3boil: unable to reload all in Form1EgaisSlice")
	}

	*o = slice

	return nil
}

// Form1EgaisExistsG checks if the Form1Egais row exists.
func Form1EgaisExistsG(ctx context.Context, iD int64) (bool, error) {
	return Form1EgaisExists(ctx, boil.GetContextDB(), iD)
}

// Form1EgaisExists checks if the Form1Egais row exists.
func Form1EgaisExists(ctx context.Context, exec boil.ContextExecutor, iD int64) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"form1_egais\" where \"id\"=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "a3boil: unable to check if form1_egais exists")
	}

	return exists, nil
}

// Exists checks if the Form1Egais row exists.
func (o *Form1Egais) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return Form1EgaisExists(ctx, exec, o.ID)
}
