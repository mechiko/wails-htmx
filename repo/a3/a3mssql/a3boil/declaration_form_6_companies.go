// Code generated by SQLBoiler 4.16.2 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package a3boil

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// DeclarationForm6Company is an object representing the database table.
type DeclarationForm6Company struct {
	ID                 int         `boil:"id" json:"id" toml:"id" yaml:"id"`
	IDDeclarationForm6 null.Int    `boil:"id_declaration_form_6" json:"id_declaration_form_6,omitempty" toml:"id_declaration_form_6" yaml:"id_declaration_form_6,omitempty"`
	Type               null.String `boil:"type" json:"type,omitempty" toml:"type" yaml:"type,omitempty"`
	FullName           null.String `boil:"full_name" json:"full_name,omitempty" toml:"full_name" yaml:"full_name,omitempty"`
	Inn                null.String `boil:"inn" json:"inn,omitempty" toml:"inn" yaml:"inn,omitempty"`
	KPP                null.String `boil:"kpp" json:"kpp,omitempty" toml:"kpp" yaml:"kpp,omitempty"`
	PostIndex          null.String `boil:"post_index" json:"post_index,omitempty" toml:"post_index" yaml:"post_index,omitempty"`
	RegionCode         null.String `boil:"region_code" json:"region_code,omitempty" toml:"region_code" yaml:"region_code,omitempty"`
	District           null.String `boil:"district" json:"district,omitempty" toml:"district" yaml:"district,omitempty"`
	City               null.String `boil:"city" json:"city,omitempty" toml:"city" yaml:"city,omitempty"`
	Locality           null.String `boil:"locality" json:"locality,omitempty" toml:"locality" yaml:"locality,omitempty"`
	Street             null.String `boil:"street" json:"street,omitempty" toml:"street" yaml:"street,omitempty"`
	House              null.String `boil:"house" json:"house,omitempty" toml:"house" yaml:"house,omitempty"`
	Building           null.String `boil:"building" json:"building,omitempty" toml:"building" yaml:"building,omitempty"`
	Letter             null.String `boil:"letter" json:"letter,omitempty" toml:"letter" yaml:"letter,omitempty"`
	Apartment          null.String `boil:"apartment" json:"apartment,omitempty" toml:"apartment" yaml:"apartment,omitempty"`
	Phone              null.String `boil:"phone" json:"phone,omitempty" toml:"phone" yaml:"phone,omitempty"`
	Email              null.String `boil:"email" json:"email,omitempty" toml:"email" yaml:"email,omitempty"`

	R *declarationForm6CompanyR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L declarationForm6CompanyL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var DeclarationForm6CompanyColumns = struct {
	ID                 string
	IDDeclarationForm6 string
	Type               string
	FullName           string
	Inn                string
	KPP                string
	PostIndex          string
	RegionCode         string
	District           string
	City               string
	Locality           string
	Street             string
	House              string
	Building           string
	Letter             string
	Apartment          string
	Phone              string
	Email              string
}{
	ID:                 "id",
	IDDeclarationForm6: "id_declaration_form_6",
	Type:               "type",
	FullName:           "full_name",
	Inn:                "inn",
	KPP:                "kpp",
	PostIndex:          "post_index",
	RegionCode:         "region_code",
	District:           "district",
	City:               "city",
	Locality:           "locality",
	Street:             "street",
	House:              "house",
	Building:           "building",
	Letter:             "letter",
	Apartment:          "apartment",
	Phone:              "phone",
	Email:              "email",
}

var DeclarationForm6CompanyTableColumns = struct {
	ID                 string
	IDDeclarationForm6 string
	Type               string
	FullName           string
	Inn                string
	KPP                string
	PostIndex          string
	RegionCode         string
	District           string
	City               string
	Locality           string
	Street             string
	House              string
	Building           string
	Letter             string
	Apartment          string
	Phone              string
	Email              string
}{
	ID:                 "declaration_form_6_companies.id",
	IDDeclarationForm6: "declaration_form_6_companies.id_declaration_form_6",
	Type:               "declaration_form_6_companies.type",
	FullName:           "declaration_form_6_companies.full_name",
	Inn:                "declaration_form_6_companies.inn",
	KPP:                "declaration_form_6_companies.kpp",
	PostIndex:          "declaration_form_6_companies.post_index",
	RegionCode:         "declaration_form_6_companies.region_code",
	District:           "declaration_form_6_companies.district",
	City:               "declaration_form_6_companies.city",
	Locality:           "declaration_form_6_companies.locality",
	Street:             "declaration_form_6_companies.street",
	House:              "declaration_form_6_companies.house",
	Building:           "declaration_form_6_companies.building",
	Letter:             "declaration_form_6_companies.letter",
	Apartment:          "declaration_form_6_companies.apartment",
	Phone:              "declaration_form_6_companies.phone",
	Email:              "declaration_form_6_companies.email",
}

// Generated where

var DeclarationForm6CompanyWhere = struct {
	ID                 whereHelperint
	IDDeclarationForm6 whereHelpernull_Int
	Type               whereHelpernull_String
	FullName           whereHelpernull_String
	Inn                whereHelpernull_String
	KPP                whereHelpernull_String
	PostIndex          whereHelpernull_String
	RegionCode         whereHelpernull_String
	District           whereHelpernull_String
	City               whereHelpernull_String
	Locality           whereHelpernull_String
	Street             whereHelpernull_String
	House              whereHelpernull_String
	Building           whereHelpernull_String
	Letter             whereHelpernull_String
	Apartment          whereHelpernull_String
	Phone              whereHelpernull_String
	Email              whereHelpernull_String
}{
	ID:                 whereHelperint{field: "[dbo].[declaration_form_6_companies].[id]"},
	IDDeclarationForm6: whereHelpernull_Int{field: "[dbo].[declaration_form_6_companies].[id_declaration_form_6]"},
	Type:               whereHelpernull_String{field: "[dbo].[declaration_form_6_companies].[type]"},
	FullName:           whereHelpernull_String{field: "[dbo].[declaration_form_6_companies].[full_name]"},
	Inn:                whereHelpernull_String{field: "[dbo].[declaration_form_6_companies].[inn]"},
	KPP:                whereHelpernull_String{field: "[dbo].[declaration_form_6_companies].[kpp]"},
	PostIndex:          whereHelpernull_String{field: "[dbo].[declaration_form_6_companies].[post_index]"},
	RegionCode:         whereHelpernull_String{field: "[dbo].[declaration_form_6_companies].[region_code]"},
	District:           whereHelpernull_String{field: "[dbo].[declaration_form_6_companies].[district]"},
	City:               whereHelpernull_String{field: "[dbo].[declaration_form_6_companies].[city]"},
	Locality:           whereHelpernull_String{field: "[dbo].[declaration_form_6_companies].[locality]"},
	Street:             whereHelpernull_String{field: "[dbo].[declaration_form_6_companies].[street]"},
	House:              whereHelpernull_String{field: "[dbo].[declaration_form_6_companies].[house]"},
	Building:           whereHelpernull_String{field: "[dbo].[declaration_form_6_companies].[building]"},
	Letter:             whereHelpernull_String{field: "[dbo].[declaration_form_6_companies].[letter]"},
	Apartment:          whereHelpernull_String{field: "[dbo].[declaration_form_6_companies].[apartment]"},
	Phone:              whereHelpernull_String{field: "[dbo].[declaration_form_6_companies].[phone]"},
	Email:              whereHelpernull_String{field: "[dbo].[declaration_form_6_companies].[email]"},
}

// DeclarationForm6CompanyRels is where relationship names are stored.
var DeclarationForm6CompanyRels = struct {
}{}

// declarationForm6CompanyR is where relationships are stored.
type declarationForm6CompanyR struct {
}

// NewStruct creates a new relationship struct
func (*declarationForm6CompanyR) NewStruct() *declarationForm6CompanyR {
	return &declarationForm6CompanyR{}
}

// declarationForm6CompanyL is where Load methods for each relationship are stored.
type declarationForm6CompanyL struct{}

var (
	declarationForm6CompanyAllColumns            = []string{"id", "id_declaration_form_6", "type", "full_name", "inn", "kpp", "post_index", "region_code", "district", "city", "locality", "street", "house", "building", "letter", "apartment", "phone", "email"}
	declarationForm6CompanyColumnsWithoutDefault = []string{"id_declaration_form_6", "type", "full_name", "inn", "kpp", "post_index", "region_code", "district", "city", "locality", "street", "house", "building", "letter", "apartment", "phone", "email"}
	declarationForm6CompanyColumnsWithDefault    = []string{"id"}
	declarationForm6CompanyPrimaryKeyColumns     = []string{"id"}
	declarationForm6CompanyGeneratedColumns      = []string{"id"}
)

type (
	// DeclarationForm6CompanySlice is an alias for a slice of pointers to DeclarationForm6Company.
	// This should almost always be used instead of []DeclarationForm6Company.
	DeclarationForm6CompanySlice []*DeclarationForm6Company
	// DeclarationForm6CompanyHook is the signature for custom DeclarationForm6Company hook methods
	DeclarationForm6CompanyHook func(context.Context, boil.ContextExecutor, *DeclarationForm6Company) error

	declarationForm6CompanyQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	declarationForm6CompanyType                 = reflect.TypeOf(&DeclarationForm6Company{})
	declarationForm6CompanyMapping              = queries.MakeStructMapping(declarationForm6CompanyType)
	declarationForm6CompanyPrimaryKeyMapping, _ = queries.BindMapping(declarationForm6CompanyType, declarationForm6CompanyMapping, declarationForm6CompanyPrimaryKeyColumns)
	declarationForm6CompanyInsertCacheMut       sync.RWMutex
	declarationForm6CompanyInsertCache          = make(map[string]insertCache)
	declarationForm6CompanyUpdateCacheMut       sync.RWMutex
	declarationForm6CompanyUpdateCache          = make(map[string]updateCache)
	declarationForm6CompanyUpsertCacheMut       sync.RWMutex
	declarationForm6CompanyUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var declarationForm6CompanyAfterSelectMu sync.Mutex
var declarationForm6CompanyAfterSelectHooks []DeclarationForm6CompanyHook

var declarationForm6CompanyBeforeInsertMu sync.Mutex
var declarationForm6CompanyBeforeInsertHooks []DeclarationForm6CompanyHook
var declarationForm6CompanyAfterInsertMu sync.Mutex
var declarationForm6CompanyAfterInsertHooks []DeclarationForm6CompanyHook

var declarationForm6CompanyBeforeUpdateMu sync.Mutex
var declarationForm6CompanyBeforeUpdateHooks []DeclarationForm6CompanyHook
var declarationForm6CompanyAfterUpdateMu sync.Mutex
var declarationForm6CompanyAfterUpdateHooks []DeclarationForm6CompanyHook

var declarationForm6CompanyBeforeDeleteMu sync.Mutex
var declarationForm6CompanyBeforeDeleteHooks []DeclarationForm6CompanyHook
var declarationForm6CompanyAfterDeleteMu sync.Mutex
var declarationForm6CompanyAfterDeleteHooks []DeclarationForm6CompanyHook

var declarationForm6CompanyBeforeUpsertMu sync.Mutex
var declarationForm6CompanyBeforeUpsertHooks []DeclarationForm6CompanyHook
var declarationForm6CompanyAfterUpsertMu sync.Mutex
var declarationForm6CompanyAfterUpsertHooks []DeclarationForm6CompanyHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *DeclarationForm6Company) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range declarationForm6CompanyAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *DeclarationForm6Company) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range declarationForm6CompanyBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *DeclarationForm6Company) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range declarationForm6CompanyAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *DeclarationForm6Company) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range declarationForm6CompanyBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *DeclarationForm6Company) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range declarationForm6CompanyAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *DeclarationForm6Company) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range declarationForm6CompanyBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *DeclarationForm6Company) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range declarationForm6CompanyAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *DeclarationForm6Company) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range declarationForm6CompanyBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *DeclarationForm6Company) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range declarationForm6CompanyAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddDeclarationForm6CompanyHook registers your hook function for all future operations.
func AddDeclarationForm6CompanyHook(hookPoint boil.HookPoint, declarationForm6CompanyHook DeclarationForm6CompanyHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		declarationForm6CompanyAfterSelectMu.Lock()
		declarationForm6CompanyAfterSelectHooks = append(declarationForm6CompanyAfterSelectHooks, declarationForm6CompanyHook)
		declarationForm6CompanyAfterSelectMu.Unlock()
	case boil.BeforeInsertHook:
		declarationForm6CompanyBeforeInsertMu.Lock()
		declarationForm6CompanyBeforeInsertHooks = append(declarationForm6CompanyBeforeInsertHooks, declarationForm6CompanyHook)
		declarationForm6CompanyBeforeInsertMu.Unlock()
	case boil.AfterInsertHook:
		declarationForm6CompanyAfterInsertMu.Lock()
		declarationForm6CompanyAfterInsertHooks = append(declarationForm6CompanyAfterInsertHooks, declarationForm6CompanyHook)
		declarationForm6CompanyAfterInsertMu.Unlock()
	case boil.BeforeUpdateHook:
		declarationForm6CompanyBeforeUpdateMu.Lock()
		declarationForm6CompanyBeforeUpdateHooks = append(declarationForm6CompanyBeforeUpdateHooks, declarationForm6CompanyHook)
		declarationForm6CompanyBeforeUpdateMu.Unlock()
	case boil.AfterUpdateHook:
		declarationForm6CompanyAfterUpdateMu.Lock()
		declarationForm6CompanyAfterUpdateHooks = append(declarationForm6CompanyAfterUpdateHooks, declarationForm6CompanyHook)
		declarationForm6CompanyAfterUpdateMu.Unlock()
	case boil.BeforeDeleteHook:
		declarationForm6CompanyBeforeDeleteMu.Lock()
		declarationForm6CompanyBeforeDeleteHooks = append(declarationForm6CompanyBeforeDeleteHooks, declarationForm6CompanyHook)
		declarationForm6CompanyBeforeDeleteMu.Unlock()
	case boil.AfterDeleteHook:
		declarationForm6CompanyAfterDeleteMu.Lock()
		declarationForm6CompanyAfterDeleteHooks = append(declarationForm6CompanyAfterDeleteHooks, declarationForm6CompanyHook)
		declarationForm6CompanyAfterDeleteMu.Unlock()
	case boil.BeforeUpsertHook:
		declarationForm6CompanyBeforeUpsertMu.Lock()
		declarationForm6CompanyBeforeUpsertHooks = append(declarationForm6CompanyBeforeUpsertHooks, declarationForm6CompanyHook)
		declarationForm6CompanyBeforeUpsertMu.Unlock()
	case boil.AfterUpsertHook:
		declarationForm6CompanyAfterUpsertMu.Lock()
		declarationForm6CompanyAfterUpsertHooks = append(declarationForm6CompanyAfterUpsertHooks, declarationForm6CompanyHook)
		declarationForm6CompanyAfterUpsertMu.Unlock()
	}
}

// OneG returns a single declarationForm6Company record from the query using the global executor.
func (q declarationForm6CompanyQuery) OneG(ctx context.Context) (*DeclarationForm6Company, error) {
	return q.One(ctx, boil.GetContextDB())
}

// One returns a single declarationForm6Company record from the query.
func (q declarationForm6CompanyQuery) One(ctx context.Context, exec boil.ContextExecutor) (*DeclarationForm6Company, error) {
	o := &DeclarationForm6Company{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "a3boil: failed to execute a one query for declaration_form_6_companies")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// AllG returns all DeclarationForm6Company records from the query using the global executor.
func (q declarationForm6CompanyQuery) AllG(ctx context.Context) (DeclarationForm6CompanySlice, error) {
	return q.All(ctx, boil.GetContextDB())
}

// All returns all DeclarationForm6Company records from the query.
func (q declarationForm6CompanyQuery) All(ctx context.Context, exec boil.ContextExecutor) (DeclarationForm6CompanySlice, error) {
	var o []*DeclarationForm6Company

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "a3boil: failed to assign all query results to DeclarationForm6Company slice")
	}

	if len(declarationForm6CompanyAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// CountG returns the count of all DeclarationForm6Company records in the query using the global executor
func (q declarationForm6CompanyQuery) CountG(ctx context.Context) (int64, error) {
	return q.Count(ctx, boil.GetContextDB())
}

// Count returns the count of all DeclarationForm6Company records in the query.
func (q declarationForm6CompanyQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "a3boil: failed to count declaration_form_6_companies rows")
	}

	return count, nil
}

// ExistsG checks if the row exists in the table using the global executor.
func (q declarationForm6CompanyQuery) ExistsG(ctx context.Context) (bool, error) {
	return q.Exists(ctx, boil.GetContextDB())
}

// Exists checks if the row exists in the table.
func (q declarationForm6CompanyQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "a3boil: failed to check if declaration_form_6_companies exists")
	}

	return count > 0, nil
}

// DeclarationForm6Companies retrieves all the records using an executor.
func DeclarationForm6Companies(mods ...qm.QueryMod) declarationForm6CompanyQuery {
	mods = append(mods, qm.From("[dbo].[declaration_form_6_companies]"))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"[dbo].[declaration_form_6_companies].*"})
	}

	return declarationForm6CompanyQuery{q}
}

// FindDeclarationForm6CompanyG retrieves a single record by ID.
func FindDeclarationForm6CompanyG(ctx context.Context, iD int, selectCols ...string) (*DeclarationForm6Company, error) {
	return FindDeclarationForm6Company(ctx, boil.GetContextDB(), iD, selectCols...)
}

// FindDeclarationForm6Company retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindDeclarationForm6Company(ctx context.Context, exec boil.ContextExecutor, iD int, selectCols ...string) (*DeclarationForm6Company, error) {
	declarationForm6CompanyObj := &DeclarationForm6Company{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from [dbo].[declaration_form_6_companies] where [id]=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, declarationForm6CompanyObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "a3boil: unable to select from declaration_form_6_companies")
	}

	if err = declarationForm6CompanyObj.doAfterSelectHooks(ctx, exec); err != nil {
		return declarationForm6CompanyObj, err
	}

	return declarationForm6CompanyObj, nil
}

// InsertG a single record. See Insert for whitelist behavior description.
func (o *DeclarationForm6Company) InsertG(ctx context.Context, columns boil.Columns) error {
	return o.Insert(ctx, boil.GetContextDB(), columns)
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *DeclarationForm6Company) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("a3boil: no declaration_form_6_companies provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(declarationForm6CompanyColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	declarationForm6CompanyInsertCacheMut.RLock()
	cache, cached := declarationForm6CompanyInsertCache[key]
	declarationForm6CompanyInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			declarationForm6CompanyAllColumns,
			declarationForm6CompanyColumnsWithDefault,
			declarationForm6CompanyColumnsWithoutDefault,
			nzDefaults,
		)
		wl = strmangle.SetComplement(wl, declarationForm6CompanyGeneratedColumns)

		cache.valueMapping, err = queries.BindMapping(declarationForm6CompanyType, declarationForm6CompanyMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(declarationForm6CompanyType, declarationForm6CompanyMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO [dbo].[declaration_form_6_companies] ([%s]) %%sVALUES (%s)%%s", strings.Join(wl, "],["), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO [dbo].[declaration_form_6_companies] %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryOutput = fmt.Sprintf("OUTPUT INSERTED.[%s] ", strings.Join(returnColumns, "],INSERTED.["))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "a3boil: unable to insert into declaration_form_6_companies")
	}

	if !cached {
		declarationForm6CompanyInsertCacheMut.Lock()
		declarationForm6CompanyInsertCache[key] = cache
		declarationForm6CompanyInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// UpdateG a single DeclarationForm6Company record using the global executor.
// See Update for more documentation.
func (o *DeclarationForm6Company) UpdateG(ctx context.Context, columns boil.Columns) (int64, error) {
	return o.Update(ctx, boil.GetContextDB(), columns)
}

// Update uses an executor to update the DeclarationForm6Company.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *DeclarationForm6Company) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	declarationForm6CompanyUpdateCacheMut.RLock()
	cache, cached := declarationForm6CompanyUpdateCache[key]
	declarationForm6CompanyUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			declarationForm6CompanyAllColumns,
			declarationForm6CompanyPrimaryKeyColumns,
		)
		wl = strmangle.SetComplement(wl, declarationForm6CompanyGeneratedColumns)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("a3boil: unable to update declaration_form_6_companies, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE [dbo].[declaration_form_6_companies] SET %s WHERE %s",
			strmangle.SetParamNames("[", "]", 1, wl),
			strmangle.WhereClause("[", "]", len(wl)+1, declarationForm6CompanyPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(declarationForm6CompanyType, declarationForm6CompanyMapping, append(wl, declarationForm6CompanyPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "a3boil: unable to update declaration_form_6_companies row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "a3boil: failed to get rows affected by update for declaration_form_6_companies")
	}

	if !cached {
		declarationForm6CompanyUpdateCacheMut.Lock()
		declarationForm6CompanyUpdateCache[key] = cache
		declarationForm6CompanyUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAllG updates all rows with the specified column values.
func (q declarationForm6CompanyQuery) UpdateAllG(ctx context.Context, cols M) (int64, error) {
	return q.UpdateAll(ctx, boil.GetContextDB(), cols)
}

// UpdateAll updates all rows with the specified column values.
func (q declarationForm6CompanyQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "a3boil: unable to update all for declaration_form_6_companies")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "a3boil: unable to retrieve rows affected for declaration_form_6_companies")
	}

	return rowsAff, nil
}

// UpdateAllG updates all rows with the specified column values.
func (o DeclarationForm6CompanySlice) UpdateAllG(ctx context.Context, cols M) (int64, error) {
	return o.UpdateAll(ctx, boil.GetContextDB(), cols)
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o DeclarationForm6CompanySlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("a3boil: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), declarationForm6CompanyPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE [dbo].[declaration_form_6_companies] SET %s WHERE %s",
		strmangle.SetParamNames("[", "]", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, declarationForm6CompanyPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "a3boil: unable to update all in declarationForm6Company slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "a3boil: unable to retrieve rows affected all in update all declarationForm6Company")
	}
	return rowsAff, nil
}

// UpsertG attempts an insert, and does an update or ignore on conflict.
func (o *DeclarationForm6Company) UpsertG(ctx context.Context, updateColumns, insertColumns boil.Columns) error {
	return o.Upsert(ctx, boil.GetContextDB(), updateColumns, insertColumns)
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
func (o *DeclarationForm6Company) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("a3boil: no declaration_form_6_companies provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(declarationForm6CompanyColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	declarationForm6CompanyUpsertCacheMut.RLock()
	cache, cached := declarationForm6CompanyUpsertCache[key]
	declarationForm6CompanyUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			declarationForm6CompanyAllColumns,
			declarationForm6CompanyColumnsWithDefault,
			declarationForm6CompanyColumnsWithoutDefault,
			nzDefaults,
		)

		insert = strmangle.SetComplement(insert, declarationForm6CompanyGeneratedColumns)

		for i, v := range insert {
			if strmangle.ContainsAny(declarationForm6CompanyPrimaryKeyColumns, v) && strmangle.ContainsAny(declarationForm6CompanyColumnsWithDefault, v) {
				insert = append(insert[:i], insert[i+1:]...)
			}
		}
		if len(insert) == 0 {
			return errors.New("a3boil: unable to upsert declaration_form_6_companies, could not build insert column list")
		}

		update := updateColumns.UpdateColumnSet(
			declarationForm6CompanyAllColumns,
			declarationForm6CompanyPrimaryKeyColumns,
		)

		insert = strmangle.SetComplement(insert, declarationForm6CompanyGeneratedColumns)

		ret := strmangle.SetComplement(declarationForm6CompanyAllColumns, strmangle.SetIntersect(insert, update))

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("a3boil: unable to upsert declaration_form_6_companies, could not build update column list")
		}

		cache.query = buildUpsertQueryMSSQL(dialect, "[dbo].[declaration_form_6_companies]", declarationForm6CompanyPrimaryKeyColumns, update, insert, ret)

		whitelist := make([]string, len(declarationForm6CompanyPrimaryKeyColumns))
		copy(whitelist, declarationForm6CompanyPrimaryKeyColumns)
		whitelist = append(whitelist, update...)
		whitelist = append(whitelist, insert...)

		cache.valueMapping, err = queries.BindMapping(declarationForm6CompanyType, declarationForm6CompanyMapping, whitelist)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(declarationForm6CompanyType, declarationForm6CompanyMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // MSSQL doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "a3boil: unable to upsert declaration_form_6_companies")
	}

	if !cached {
		declarationForm6CompanyUpsertCacheMut.Lock()
		declarationForm6CompanyUpsertCache[key] = cache
		declarationForm6CompanyUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// DeleteG deletes a single DeclarationForm6Company record.
// DeleteG will match against the primary key column to find the record to delete.
func (o *DeclarationForm6Company) DeleteG(ctx context.Context) (int64, error) {
	return o.Delete(ctx, boil.GetContextDB())
}

// Delete deletes a single DeclarationForm6Company record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *DeclarationForm6Company) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("a3boil: no DeclarationForm6Company provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), declarationForm6CompanyPrimaryKeyMapping)
	sql := "DELETE FROM [dbo].[declaration_form_6_companies] WHERE [id]=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "a3boil: unable to delete from declaration_form_6_companies")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "a3boil: failed to get rows affected by delete for declaration_form_6_companies")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

func (q declarationForm6CompanyQuery) DeleteAllG(ctx context.Context) (int64, error) {
	return q.DeleteAll(ctx, boil.GetContextDB())
}

// DeleteAll deletes all matching rows.
func (q declarationForm6CompanyQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("a3boil: no declarationForm6CompanyQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "a3boil: unable to delete all from declaration_form_6_companies")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "a3boil: failed to get rows affected by deleteall for declaration_form_6_companies")
	}

	return rowsAff, nil
}

// DeleteAllG deletes all rows in the slice.
func (o DeclarationForm6CompanySlice) DeleteAllG(ctx context.Context) (int64, error) {
	return o.DeleteAll(ctx, boil.GetContextDB())
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o DeclarationForm6CompanySlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(declarationForm6CompanyBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), declarationForm6CompanyPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM [dbo].[declaration_form_6_companies] WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, declarationForm6CompanyPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "a3boil: unable to delete all from declarationForm6Company slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "a3boil: failed to get rows affected by deleteall for declaration_form_6_companies")
	}

	if len(declarationForm6CompanyAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// ReloadG refetches the object from the database using the primary keys.
func (o *DeclarationForm6Company) ReloadG(ctx context.Context) error {
	if o == nil {
		return errors.New("a3boil: no DeclarationForm6Company provided for reload")
	}

	return o.Reload(ctx, boil.GetContextDB())
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *DeclarationForm6Company) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindDeclarationForm6Company(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAllG refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *DeclarationForm6CompanySlice) ReloadAllG(ctx context.Context) error {
	if o == nil {
		return errors.New("a3boil: empty DeclarationForm6CompanySlice provided for reload all")
	}

	return o.ReloadAll(ctx, boil.GetContextDB())
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *DeclarationForm6CompanySlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := DeclarationForm6CompanySlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), declarationForm6CompanyPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT [dbo].[declaration_form_6_companies].* FROM [dbo].[declaration_form_6_companies] WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, declarationForm6CompanyPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "a3boil: unable to reload all in DeclarationForm6CompanySlice")
	}

	*o = slice

	return nil
}

// DeclarationForm6CompanyExistsG checks if the DeclarationForm6Company row exists.
func DeclarationForm6CompanyExistsG(ctx context.Context, iD int) (bool, error) {
	return DeclarationForm6CompanyExists(ctx, boil.GetContextDB(), iD)
}

// DeclarationForm6CompanyExists checks if the DeclarationForm6Company row exists.
func DeclarationForm6CompanyExists(ctx context.Context, exec boil.ContextExecutor, iD int) (bool, error) {
	var exists bool
	sql := "select case when exists(select top(1) 1 from [dbo].[declaration_form_6_companies] where [id]=$1) then 1 else 0 end"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "a3boil: unable to check if declaration_form_6_companies exists")
	}

	return exists, nil
}

// Exists checks if the DeclarationForm6Company row exists.
func (o *DeclarationForm6Company) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return DeclarationForm6CompanyExists(ctx, exec, o.ID)
}
