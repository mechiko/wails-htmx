// Code generated by SQLBoiler 4.16.2 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package a3boil

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// TTNProduct is an object representing the database table.
type TTNProduct struct {
	ID                   int         `boil:"id" json:"id" toml:"id" yaml:"id"`
	IDTTN                null.Int    `boil:"id_ttn" json:"id_ttn,omitempty" toml:"id_ttn" yaml:"id_ttn,omitempty"`
	ProductFullName      null.String `boil:"product_full_name" json:"product_full_name,omitempty" toml:"product_full_name" yaml:"product_full_name,omitempty"`
	ProductCapacity      null.String `boil:"product_capacity" json:"product_capacity,omitempty" toml:"product_capacity" yaml:"product_capacity,omitempty"`
	ProductAlcVolume     null.String `boil:"product_alc_volume" json:"product_alc_volume,omitempty" toml:"product_alc_volume" yaml:"product_alc_volume,omitempty"`
	ProductAlcCode       null.String `boil:"product_alc_code" json:"product_alc_code,omitempty" toml:"product_alc_code" yaml:"product_alc_code,omitempty"`
	ProductCode          null.String `boil:"product_code" json:"product_code,omitempty" toml:"product_code" yaml:"product_code,omitempty"`
	ProductUnitType      null.String `boil:"product_unit_type" json:"product_unit_type,omitempty" toml:"product_unit_type" yaml:"product_unit_type,omitempty"`
	ProductIddomain      null.String `boil:"product_iddomain" json:"product_iddomain,omitempty" toml:"product_iddomain" yaml:"product_iddomain,omitempty"`
	ProductQuantity      null.String `boil:"product_quantity" json:"product_quantity,omitempty" toml:"product_quantity" yaml:"product_quantity,omitempty"`
	ProductPrice         null.String `boil:"product_price" json:"product_price,omitempty" toml:"product_price" yaml:"product_price,omitempty"`
	ProductParty         null.String `boil:"product_party" json:"product_party,omitempty" toml:"product_party" yaml:"product_party,omitempty"`
	ProductPackID        null.String `boil:"product_pack_id" json:"product_pack_id,omitempty" toml:"product_pack_id" yaml:"product_pack_id,omitempty"`
	ProductInformF1RegID null.String `boil:"product_inform_f1_reg_id" json:"product_inform_f1_reg_id,omitempty" toml:"product_inform_f1_reg_id" yaml:"product_inform_f1_reg_id,omitempty"`
	ProductInformF2RegID null.String `boil:"product_inform_f2_reg_id" json:"product_inform_f2_reg_id,omitempty" toml:"product_inform_f2_reg_id" yaml:"product_inform_f2_reg_id,omitempty"`
	ProducerType         null.String `boil:"producer_type" json:"producer_type,omitempty" toml:"producer_type" yaml:"producer_type,omitempty"`
	ProducerClientRegID  null.String `boil:"producer_client_reg_id" json:"producer_client_reg_id,omitempty" toml:"producer_client_reg_id" yaml:"producer_client_reg_id,omitempty"`
	ProducerInn          null.String `boil:"producer_inn" json:"producer_inn,omitempty" toml:"producer_inn" yaml:"producer_inn,omitempty"`
	ProducerKPP          null.String `boil:"producer_kpp" json:"producer_kpp,omitempty" toml:"producer_kpp" yaml:"producer_kpp,omitempty"`
	ProducerFullName     null.String `boil:"producer_full_name" json:"producer_full_name,omitempty" toml:"producer_full_name" yaml:"producer_full_name,omitempty"`
	ProducerShortName    null.String `boil:"producer_short_name" json:"producer_short_name,omitempty" toml:"producer_short_name" yaml:"producer_short_name,omitempty"`
	ProducerCountryCode  null.String `boil:"producer_country_code" json:"producer_country_code,omitempty" toml:"producer_country_code" yaml:"producer_country_code,omitempty"`
	ProducerRegionCode   null.String `boil:"producer_region_code" json:"producer_region_code,omitempty" toml:"producer_region_code" yaml:"producer_region_code,omitempty"`
	ProducerDescription  null.String `boil:"producer_description" json:"producer_description,omitempty" toml:"producer_description" yaml:"producer_description,omitempty"`

	R *ttnProductR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L ttnProductL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var TTNProductColumns = struct {
	ID                   string
	IDTTN                string
	ProductFullName      string
	ProductCapacity      string
	ProductAlcVolume     string
	ProductAlcCode       string
	ProductCode          string
	ProductUnitType      string
	ProductIddomain      string
	ProductQuantity      string
	ProductPrice         string
	ProductParty         string
	ProductPackID        string
	ProductInformF1RegID string
	ProductInformF2RegID string
	ProducerType         string
	ProducerClientRegID  string
	ProducerInn          string
	ProducerKPP          string
	ProducerFullName     string
	ProducerShortName    string
	ProducerCountryCode  string
	ProducerRegionCode   string
	ProducerDescription  string
}{
	ID:                   "id",
	IDTTN:                "id_ttn",
	ProductFullName:      "product_full_name",
	ProductCapacity:      "product_capacity",
	ProductAlcVolume:     "product_alc_volume",
	ProductAlcCode:       "product_alc_code",
	ProductCode:          "product_code",
	ProductUnitType:      "product_unit_type",
	ProductIddomain:      "product_iddomain",
	ProductQuantity:      "product_quantity",
	ProductPrice:         "product_price",
	ProductParty:         "product_party",
	ProductPackID:        "product_pack_id",
	ProductInformF1RegID: "product_inform_f1_reg_id",
	ProductInformF2RegID: "product_inform_f2_reg_id",
	ProducerType:         "producer_type",
	ProducerClientRegID:  "producer_client_reg_id",
	ProducerInn:          "producer_inn",
	ProducerKPP:          "producer_kpp",
	ProducerFullName:     "producer_full_name",
	ProducerShortName:    "producer_short_name",
	ProducerCountryCode:  "producer_country_code",
	ProducerRegionCode:   "producer_region_code",
	ProducerDescription:  "producer_description",
}

var TTNProductTableColumns = struct {
	ID                   string
	IDTTN                string
	ProductFullName      string
	ProductCapacity      string
	ProductAlcVolume     string
	ProductAlcCode       string
	ProductCode          string
	ProductUnitType      string
	ProductIddomain      string
	ProductQuantity      string
	ProductPrice         string
	ProductParty         string
	ProductPackID        string
	ProductInformF1RegID string
	ProductInformF2RegID string
	ProducerType         string
	ProducerClientRegID  string
	ProducerInn          string
	ProducerKPP          string
	ProducerFullName     string
	ProducerShortName    string
	ProducerCountryCode  string
	ProducerRegionCode   string
	ProducerDescription  string
}{
	ID:                   "ttn_products.id",
	IDTTN:                "ttn_products.id_ttn",
	ProductFullName:      "ttn_products.product_full_name",
	ProductCapacity:      "ttn_products.product_capacity",
	ProductAlcVolume:     "ttn_products.product_alc_volume",
	ProductAlcCode:       "ttn_products.product_alc_code",
	ProductCode:          "ttn_products.product_code",
	ProductUnitType:      "ttn_products.product_unit_type",
	ProductIddomain:      "ttn_products.product_iddomain",
	ProductQuantity:      "ttn_products.product_quantity",
	ProductPrice:         "ttn_products.product_price",
	ProductParty:         "ttn_products.product_party",
	ProductPackID:        "ttn_products.product_pack_id",
	ProductInformF1RegID: "ttn_products.product_inform_f1_reg_id",
	ProductInformF2RegID: "ttn_products.product_inform_f2_reg_id",
	ProducerType:         "ttn_products.producer_type",
	ProducerClientRegID:  "ttn_products.producer_client_reg_id",
	ProducerInn:          "ttn_products.producer_inn",
	ProducerKPP:          "ttn_products.producer_kpp",
	ProducerFullName:     "ttn_products.producer_full_name",
	ProducerShortName:    "ttn_products.producer_short_name",
	ProducerCountryCode:  "ttn_products.producer_country_code",
	ProducerRegionCode:   "ttn_products.producer_region_code",
	ProducerDescription:  "ttn_products.producer_description",
}

// Generated where

var TTNProductWhere = struct {
	ID                   whereHelperint
	IDTTN                whereHelpernull_Int
	ProductFullName      whereHelpernull_String
	ProductCapacity      whereHelpernull_String
	ProductAlcVolume     whereHelpernull_String
	ProductAlcCode       whereHelpernull_String
	ProductCode          whereHelpernull_String
	ProductUnitType      whereHelpernull_String
	ProductIddomain      whereHelpernull_String
	ProductQuantity      whereHelpernull_String
	ProductPrice         whereHelpernull_String
	ProductParty         whereHelpernull_String
	ProductPackID        whereHelpernull_String
	ProductInformF1RegID whereHelpernull_String
	ProductInformF2RegID whereHelpernull_String
	ProducerType         whereHelpernull_String
	ProducerClientRegID  whereHelpernull_String
	ProducerInn          whereHelpernull_String
	ProducerKPP          whereHelpernull_String
	ProducerFullName     whereHelpernull_String
	ProducerShortName    whereHelpernull_String
	ProducerCountryCode  whereHelpernull_String
	ProducerRegionCode   whereHelpernull_String
	ProducerDescription  whereHelpernull_String
}{
	ID:                   whereHelperint{field: "[dbo].[ttn_products].[id]"},
	IDTTN:                whereHelpernull_Int{field: "[dbo].[ttn_products].[id_ttn]"},
	ProductFullName:      whereHelpernull_String{field: "[dbo].[ttn_products].[product_full_name]"},
	ProductCapacity:      whereHelpernull_String{field: "[dbo].[ttn_products].[product_capacity]"},
	ProductAlcVolume:     whereHelpernull_String{field: "[dbo].[ttn_products].[product_alc_volume]"},
	ProductAlcCode:       whereHelpernull_String{field: "[dbo].[ttn_products].[product_alc_code]"},
	ProductCode:          whereHelpernull_String{field: "[dbo].[ttn_products].[product_code]"},
	ProductUnitType:      whereHelpernull_String{field: "[dbo].[ttn_products].[product_unit_type]"},
	ProductIddomain:      whereHelpernull_String{field: "[dbo].[ttn_products].[product_iddomain]"},
	ProductQuantity:      whereHelpernull_String{field: "[dbo].[ttn_products].[product_quantity]"},
	ProductPrice:         whereHelpernull_String{field: "[dbo].[ttn_products].[product_price]"},
	ProductParty:         whereHelpernull_String{field: "[dbo].[ttn_products].[product_party]"},
	ProductPackID:        whereHelpernull_String{field: "[dbo].[ttn_products].[product_pack_id]"},
	ProductInformF1RegID: whereHelpernull_String{field: "[dbo].[ttn_products].[product_inform_f1_reg_id]"},
	ProductInformF2RegID: whereHelpernull_String{field: "[dbo].[ttn_products].[product_inform_f2_reg_id]"},
	ProducerType:         whereHelpernull_String{field: "[dbo].[ttn_products].[producer_type]"},
	ProducerClientRegID:  whereHelpernull_String{field: "[dbo].[ttn_products].[producer_client_reg_id]"},
	ProducerInn:          whereHelpernull_String{field: "[dbo].[ttn_products].[producer_inn]"},
	ProducerKPP:          whereHelpernull_String{field: "[dbo].[ttn_products].[producer_kpp]"},
	ProducerFullName:     whereHelpernull_String{field: "[dbo].[ttn_products].[producer_full_name]"},
	ProducerShortName:    whereHelpernull_String{field: "[dbo].[ttn_products].[producer_short_name]"},
	ProducerCountryCode:  whereHelpernull_String{field: "[dbo].[ttn_products].[producer_country_code]"},
	ProducerRegionCode:   whereHelpernull_String{field: "[dbo].[ttn_products].[producer_region_code]"},
	ProducerDescription:  whereHelpernull_String{field: "[dbo].[ttn_products].[producer_description]"},
}

// TTNProductRels is where relationship names are stored.
var TTNProductRels = struct {
}{}

// ttnProductR is where relationships are stored.
type ttnProductR struct {
}

// NewStruct creates a new relationship struct
func (*ttnProductR) NewStruct() *ttnProductR {
	return &ttnProductR{}
}

// ttnProductL is where Load methods for each relationship are stored.
type ttnProductL struct{}

var (
	ttnProductAllColumns            = []string{"id", "id_ttn", "product_full_name", "product_capacity", "product_alc_volume", "product_alc_code", "product_code", "product_unit_type", "product_iddomain", "product_quantity", "product_price", "product_party", "product_pack_id", "product_inform_f1_reg_id", "product_inform_f2_reg_id", "producer_type", "producer_client_reg_id", "producer_inn", "producer_kpp", "producer_full_name", "producer_short_name", "producer_country_code", "producer_region_code", "producer_description"}
	ttnProductColumnsWithoutDefault = []string{"id_ttn", "product_full_name", "product_capacity", "product_alc_volume", "product_alc_code", "product_code", "product_unit_type", "product_iddomain", "product_quantity", "product_price", "product_party", "product_pack_id", "product_inform_f1_reg_id", "product_inform_f2_reg_id", "producer_type", "producer_client_reg_id", "producer_inn", "producer_kpp", "producer_full_name", "producer_short_name", "producer_country_code", "producer_region_code", "producer_description"}
	ttnProductColumnsWithDefault    = []string{"id"}
	ttnProductPrimaryKeyColumns     = []string{"id"}
	ttnProductGeneratedColumns      = []string{"id"}
)

type (
	// TTNProductSlice is an alias for a slice of pointers to TTNProduct.
	// This should almost always be used instead of []TTNProduct.
	TTNProductSlice []*TTNProduct
	// TTNProductHook is the signature for custom TTNProduct hook methods
	TTNProductHook func(context.Context, boil.ContextExecutor, *TTNProduct) error

	ttnProductQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	ttnProductType                 = reflect.TypeOf(&TTNProduct{})
	ttnProductMapping              = queries.MakeStructMapping(ttnProductType)
	ttnProductPrimaryKeyMapping, _ = queries.BindMapping(ttnProductType, ttnProductMapping, ttnProductPrimaryKeyColumns)
	ttnProductInsertCacheMut       sync.RWMutex
	ttnProductInsertCache          = make(map[string]insertCache)
	ttnProductUpdateCacheMut       sync.RWMutex
	ttnProductUpdateCache          = make(map[string]updateCache)
	ttnProductUpsertCacheMut       sync.RWMutex
	ttnProductUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var ttnProductAfterSelectMu sync.Mutex
var ttnProductAfterSelectHooks []TTNProductHook

var ttnProductBeforeInsertMu sync.Mutex
var ttnProductBeforeInsertHooks []TTNProductHook
var ttnProductAfterInsertMu sync.Mutex
var ttnProductAfterInsertHooks []TTNProductHook

var ttnProductBeforeUpdateMu sync.Mutex
var ttnProductBeforeUpdateHooks []TTNProductHook
var ttnProductAfterUpdateMu sync.Mutex
var ttnProductAfterUpdateHooks []TTNProductHook

var ttnProductBeforeDeleteMu sync.Mutex
var ttnProductBeforeDeleteHooks []TTNProductHook
var ttnProductAfterDeleteMu sync.Mutex
var ttnProductAfterDeleteHooks []TTNProductHook

var ttnProductBeforeUpsertMu sync.Mutex
var ttnProductBeforeUpsertHooks []TTNProductHook
var ttnProductAfterUpsertMu sync.Mutex
var ttnProductAfterUpsertHooks []TTNProductHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *TTNProduct) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range ttnProductAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *TTNProduct) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range ttnProductBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *TTNProduct) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range ttnProductAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *TTNProduct) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range ttnProductBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *TTNProduct) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range ttnProductAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *TTNProduct) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range ttnProductBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *TTNProduct) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range ttnProductAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *TTNProduct) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range ttnProductBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *TTNProduct) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range ttnProductAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddTTNProductHook registers your hook function for all future operations.
func AddTTNProductHook(hookPoint boil.HookPoint, ttnProductHook TTNProductHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		ttnProductAfterSelectMu.Lock()
		ttnProductAfterSelectHooks = append(ttnProductAfterSelectHooks, ttnProductHook)
		ttnProductAfterSelectMu.Unlock()
	case boil.BeforeInsertHook:
		ttnProductBeforeInsertMu.Lock()
		ttnProductBeforeInsertHooks = append(ttnProductBeforeInsertHooks, ttnProductHook)
		ttnProductBeforeInsertMu.Unlock()
	case boil.AfterInsertHook:
		ttnProductAfterInsertMu.Lock()
		ttnProductAfterInsertHooks = append(ttnProductAfterInsertHooks, ttnProductHook)
		ttnProductAfterInsertMu.Unlock()
	case boil.BeforeUpdateHook:
		ttnProductBeforeUpdateMu.Lock()
		ttnProductBeforeUpdateHooks = append(ttnProductBeforeUpdateHooks, ttnProductHook)
		ttnProductBeforeUpdateMu.Unlock()
	case boil.AfterUpdateHook:
		ttnProductAfterUpdateMu.Lock()
		ttnProductAfterUpdateHooks = append(ttnProductAfterUpdateHooks, ttnProductHook)
		ttnProductAfterUpdateMu.Unlock()
	case boil.BeforeDeleteHook:
		ttnProductBeforeDeleteMu.Lock()
		ttnProductBeforeDeleteHooks = append(ttnProductBeforeDeleteHooks, ttnProductHook)
		ttnProductBeforeDeleteMu.Unlock()
	case boil.AfterDeleteHook:
		ttnProductAfterDeleteMu.Lock()
		ttnProductAfterDeleteHooks = append(ttnProductAfterDeleteHooks, ttnProductHook)
		ttnProductAfterDeleteMu.Unlock()
	case boil.BeforeUpsertHook:
		ttnProductBeforeUpsertMu.Lock()
		ttnProductBeforeUpsertHooks = append(ttnProductBeforeUpsertHooks, ttnProductHook)
		ttnProductBeforeUpsertMu.Unlock()
	case boil.AfterUpsertHook:
		ttnProductAfterUpsertMu.Lock()
		ttnProductAfterUpsertHooks = append(ttnProductAfterUpsertHooks, ttnProductHook)
		ttnProductAfterUpsertMu.Unlock()
	}
}

// OneG returns a single ttnProduct record from the query using the global executor.
func (q ttnProductQuery) OneG(ctx context.Context) (*TTNProduct, error) {
	return q.One(ctx, boil.GetContextDB())
}

// One returns a single ttnProduct record from the query.
func (q ttnProductQuery) One(ctx context.Context, exec boil.ContextExecutor) (*TTNProduct, error) {
	o := &TTNProduct{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "a3boil: failed to execute a one query for ttn_products")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// AllG returns all TTNProduct records from the query using the global executor.
func (q ttnProductQuery) AllG(ctx context.Context) (TTNProductSlice, error) {
	return q.All(ctx, boil.GetContextDB())
}

// All returns all TTNProduct records from the query.
func (q ttnProductQuery) All(ctx context.Context, exec boil.ContextExecutor) (TTNProductSlice, error) {
	var o []*TTNProduct

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "a3boil: failed to assign all query results to TTNProduct slice")
	}

	if len(ttnProductAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// CountG returns the count of all TTNProduct records in the query using the global executor
func (q ttnProductQuery) CountG(ctx context.Context) (int64, error) {
	return q.Count(ctx, boil.GetContextDB())
}

// Count returns the count of all TTNProduct records in the query.
func (q ttnProductQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "a3boil: failed to count ttn_products rows")
	}

	return count, nil
}

// ExistsG checks if the row exists in the table using the global executor.
func (q ttnProductQuery) ExistsG(ctx context.Context) (bool, error) {
	return q.Exists(ctx, boil.GetContextDB())
}

// Exists checks if the row exists in the table.
func (q ttnProductQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "a3boil: failed to check if ttn_products exists")
	}

	return count > 0, nil
}

// TTNProducts retrieves all the records using an executor.
func TTNProducts(mods ...qm.QueryMod) ttnProductQuery {
	mods = append(mods, qm.From("[dbo].[ttn_products]"))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"[dbo].[ttn_products].*"})
	}

	return ttnProductQuery{q}
}

// FindTTNProductG retrieves a single record by ID.
func FindTTNProductG(ctx context.Context, iD int, selectCols ...string) (*TTNProduct, error) {
	return FindTTNProduct(ctx, boil.GetContextDB(), iD, selectCols...)
}

// FindTTNProduct retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindTTNProduct(ctx context.Context, exec boil.ContextExecutor, iD int, selectCols ...string) (*TTNProduct, error) {
	ttnProductObj := &TTNProduct{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from [dbo].[ttn_products] where [id]=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, ttnProductObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "a3boil: unable to select from ttn_products")
	}

	if err = ttnProductObj.doAfterSelectHooks(ctx, exec); err != nil {
		return ttnProductObj, err
	}

	return ttnProductObj, nil
}

// InsertG a single record. See Insert for whitelist behavior description.
func (o *TTNProduct) InsertG(ctx context.Context, columns boil.Columns) error {
	return o.Insert(ctx, boil.GetContextDB(), columns)
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *TTNProduct) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("a3boil: no ttn_products provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(ttnProductColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	ttnProductInsertCacheMut.RLock()
	cache, cached := ttnProductInsertCache[key]
	ttnProductInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			ttnProductAllColumns,
			ttnProductColumnsWithDefault,
			ttnProductColumnsWithoutDefault,
			nzDefaults,
		)
		wl = strmangle.SetComplement(wl, ttnProductGeneratedColumns)

		cache.valueMapping, err = queries.BindMapping(ttnProductType, ttnProductMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(ttnProductType, ttnProductMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO [dbo].[ttn_products] ([%s]) %%sVALUES (%s)%%s", strings.Join(wl, "],["), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO [dbo].[ttn_products] %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryOutput = fmt.Sprintf("OUTPUT INSERTED.[%s] ", strings.Join(returnColumns, "],INSERTED.["))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "a3boil: unable to insert into ttn_products")
	}

	if !cached {
		ttnProductInsertCacheMut.Lock()
		ttnProductInsertCache[key] = cache
		ttnProductInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// UpdateG a single TTNProduct record using the global executor.
// See Update for more documentation.
func (o *TTNProduct) UpdateG(ctx context.Context, columns boil.Columns) (int64, error) {
	return o.Update(ctx, boil.GetContextDB(), columns)
}

// Update uses an executor to update the TTNProduct.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *TTNProduct) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	ttnProductUpdateCacheMut.RLock()
	cache, cached := ttnProductUpdateCache[key]
	ttnProductUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			ttnProductAllColumns,
			ttnProductPrimaryKeyColumns,
		)
		wl = strmangle.SetComplement(wl, ttnProductGeneratedColumns)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("a3boil: unable to update ttn_products, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE [dbo].[ttn_products] SET %s WHERE %s",
			strmangle.SetParamNames("[", "]", 1, wl),
			strmangle.WhereClause("[", "]", len(wl)+1, ttnProductPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(ttnProductType, ttnProductMapping, append(wl, ttnProductPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "a3boil: unable to update ttn_products row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "a3boil: failed to get rows affected by update for ttn_products")
	}

	if !cached {
		ttnProductUpdateCacheMut.Lock()
		ttnProductUpdateCache[key] = cache
		ttnProductUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAllG updates all rows with the specified column values.
func (q ttnProductQuery) UpdateAllG(ctx context.Context, cols M) (int64, error) {
	return q.UpdateAll(ctx, boil.GetContextDB(), cols)
}

// UpdateAll updates all rows with the specified column values.
func (q ttnProductQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "a3boil: unable to update all for ttn_products")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "a3boil: unable to retrieve rows affected for ttn_products")
	}

	return rowsAff, nil
}

// UpdateAllG updates all rows with the specified column values.
func (o TTNProductSlice) UpdateAllG(ctx context.Context, cols M) (int64, error) {
	return o.UpdateAll(ctx, boil.GetContextDB(), cols)
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o TTNProductSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("a3boil: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), ttnProductPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE [dbo].[ttn_products] SET %s WHERE %s",
		strmangle.SetParamNames("[", "]", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, ttnProductPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "a3boil: unable to update all in ttnProduct slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "a3boil: unable to retrieve rows affected all in update all ttnProduct")
	}
	return rowsAff, nil
}

// UpsertG attempts an insert, and does an update or ignore on conflict.
func (o *TTNProduct) UpsertG(ctx context.Context, updateColumns, insertColumns boil.Columns) error {
	return o.Upsert(ctx, boil.GetContextDB(), updateColumns, insertColumns)
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
func (o *TTNProduct) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("a3boil: no ttn_products provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(ttnProductColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	ttnProductUpsertCacheMut.RLock()
	cache, cached := ttnProductUpsertCache[key]
	ttnProductUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			ttnProductAllColumns,
			ttnProductColumnsWithDefault,
			ttnProductColumnsWithoutDefault,
			nzDefaults,
		)

		insert = strmangle.SetComplement(insert, ttnProductGeneratedColumns)

		for i, v := range insert {
			if strmangle.ContainsAny(ttnProductPrimaryKeyColumns, v) && strmangle.ContainsAny(ttnProductColumnsWithDefault, v) {
				insert = append(insert[:i], insert[i+1:]...)
			}
		}
		if len(insert) == 0 {
			return errors.New("a3boil: unable to upsert ttn_products, could not build insert column list")
		}

		update := updateColumns.UpdateColumnSet(
			ttnProductAllColumns,
			ttnProductPrimaryKeyColumns,
		)

		insert = strmangle.SetComplement(insert, ttnProductGeneratedColumns)

		ret := strmangle.SetComplement(ttnProductAllColumns, strmangle.SetIntersect(insert, update))

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("a3boil: unable to upsert ttn_products, could not build update column list")
		}

		cache.query = buildUpsertQueryMSSQL(dialect, "[dbo].[ttn_products]", ttnProductPrimaryKeyColumns, update, insert, ret)

		whitelist := make([]string, len(ttnProductPrimaryKeyColumns))
		copy(whitelist, ttnProductPrimaryKeyColumns)
		whitelist = append(whitelist, update...)
		whitelist = append(whitelist, insert...)

		cache.valueMapping, err = queries.BindMapping(ttnProductType, ttnProductMapping, whitelist)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(ttnProductType, ttnProductMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // MSSQL doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "a3boil: unable to upsert ttn_products")
	}

	if !cached {
		ttnProductUpsertCacheMut.Lock()
		ttnProductUpsertCache[key] = cache
		ttnProductUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// DeleteG deletes a single TTNProduct record.
// DeleteG will match against the primary key column to find the record to delete.
func (o *TTNProduct) DeleteG(ctx context.Context) (int64, error) {
	return o.Delete(ctx, boil.GetContextDB())
}

// Delete deletes a single TTNProduct record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *TTNProduct) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("a3boil: no TTNProduct provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), ttnProductPrimaryKeyMapping)
	sql := "DELETE FROM [dbo].[ttn_products] WHERE [id]=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "a3boil: unable to delete from ttn_products")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "a3boil: failed to get rows affected by delete for ttn_products")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

func (q ttnProductQuery) DeleteAllG(ctx context.Context) (int64, error) {
	return q.DeleteAll(ctx, boil.GetContextDB())
}

// DeleteAll deletes all matching rows.
func (q ttnProductQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("a3boil: no ttnProductQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "a3boil: unable to delete all from ttn_products")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "a3boil: failed to get rows affected by deleteall for ttn_products")
	}

	return rowsAff, nil
}

// DeleteAllG deletes all rows in the slice.
func (o TTNProductSlice) DeleteAllG(ctx context.Context) (int64, error) {
	return o.DeleteAll(ctx, boil.GetContextDB())
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o TTNProductSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(ttnProductBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), ttnProductPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM [dbo].[ttn_products] WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, ttnProductPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "a3boil: unable to delete all from ttnProduct slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "a3boil: failed to get rows affected by deleteall for ttn_products")
	}

	if len(ttnProductAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// ReloadG refetches the object from the database using the primary keys.
func (o *TTNProduct) ReloadG(ctx context.Context) error {
	if o == nil {
		return errors.New("a3boil: no TTNProduct provided for reload")
	}

	return o.Reload(ctx, boil.GetContextDB())
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *TTNProduct) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindTTNProduct(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAllG refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *TTNProductSlice) ReloadAllG(ctx context.Context) error {
	if o == nil {
		return errors.New("a3boil: empty TTNProductSlice provided for reload all")
	}

	return o.ReloadAll(ctx, boil.GetContextDB())
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *TTNProductSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := TTNProductSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), ttnProductPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT [dbo].[ttn_products].* FROM [dbo].[ttn_products] WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, ttnProductPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "a3boil: unable to reload all in TTNProductSlice")
	}

	*o = slice

	return nil
}

// TTNProductExistsG checks if the TTNProduct row exists.
func TTNProductExistsG(ctx context.Context, iD int) (bool, error) {
	return TTNProductExists(ctx, boil.GetContextDB(), iD)
}

// TTNProductExists checks if the TTNProduct row exists.
func TTNProductExists(ctx context.Context, exec boil.ContextExecutor, iD int) (bool, error) {
	var exists bool
	sql := "select case when exists(select top(1) 1 from [dbo].[ttn_products] where [id]=$1) then 1 else 0 end"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "a3boil: unable to check if ttn_products exists")
	}

	return exists, nil
}

// Exists checks if the TTNProduct row exists.
func (o *TTNProduct) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return TTNProductExists(ctx, exec, o.ID)
}
