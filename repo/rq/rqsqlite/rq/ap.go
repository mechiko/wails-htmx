// Code generated by SQLBoiler 4.16.2 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package rq

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// Ap is an object representing the database table.
type Ap struct {
	Alccode             string `boil:"alccode" json:"alccode" toml:"alccode" yaml:"alccode"`
	RequestID           int64  `boil:"request_id" json:"request_id" toml:"request_id" yaml:"request_id"`
	Fullname            string `boil:"fullname" json:"fullname" toml:"fullname" yaml:"fullname"`
	Capacity            string `boil:"capacity" json:"capacity" toml:"capacity" yaml:"capacity"`
	Unittype            string `boil:"unittype" json:"unittype" toml:"unittype" yaml:"unittype"`
	Alcvolume           string `boil:"alcvolume" json:"alcvolume" toml:"alcvolume" yaml:"alcvolume"`
	Packtype            string `boil:"packtype" json:"packtype" toml:"packtype" yaml:"packtype"`
	Productvcode        string `boil:"productvcode" json:"productvcode" toml:"productvcode" yaml:"productvcode"`
	Producerclientregid string `boil:"producerclientregid" json:"producerclientregid" toml:"producerclientregid" yaml:"producerclientregid"`
	Producertype        string `boil:"producertype" json:"producertype" toml:"producertype" yaml:"producertype"`
	Producerfullname    string `boil:"producerfullname" json:"producerfullname" toml:"producerfullname" yaml:"producerfullname"`
	Producershortname   string `boil:"producershortname" json:"producershortname" toml:"producershortname" yaml:"producershortname"`
	Producercountry     string `boil:"producercountry" json:"producercountry" toml:"producercountry" yaml:"producercountry"`
	Producerregioncode  string `boil:"producerregioncode" json:"producerregioncode" toml:"producerregioncode" yaml:"producerregioncode"`
	Producerdescription string `boil:"producerdescription" json:"producerdescription" toml:"producerdescription" yaml:"producerdescription"`

	R *apR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L apL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var ApColumns = struct {
	Alccode             string
	RequestID           string
	Fullname            string
	Capacity            string
	Unittype            string
	Alcvolume           string
	Packtype            string
	Productvcode        string
	Producerclientregid string
	Producertype        string
	Producerfullname    string
	Producershortname   string
	Producercountry     string
	Producerregioncode  string
	Producerdescription string
}{
	Alccode:             "alccode",
	RequestID:           "request_id",
	Fullname:            "fullname",
	Capacity:            "capacity",
	Unittype:            "unittype",
	Alcvolume:           "alcvolume",
	Packtype:            "packtype",
	Productvcode:        "productvcode",
	Producerclientregid: "producerclientregid",
	Producertype:        "producertype",
	Producerfullname:    "producerfullname",
	Producershortname:   "producershortname",
	Producercountry:     "producercountry",
	Producerregioncode:  "producerregioncode",
	Producerdescription: "producerdescription",
}

var ApTableColumns = struct {
	Alccode             string
	RequestID           string
	Fullname            string
	Capacity            string
	Unittype            string
	Alcvolume           string
	Packtype            string
	Productvcode        string
	Producerclientregid string
	Producertype        string
	Producerfullname    string
	Producershortname   string
	Producercountry     string
	Producerregioncode  string
	Producerdescription string
}{
	Alccode:             "ap.alccode",
	RequestID:           "ap.request_id",
	Fullname:            "ap.fullname",
	Capacity:            "ap.capacity",
	Unittype:            "ap.unittype",
	Alcvolume:           "ap.alcvolume",
	Packtype:            "ap.packtype",
	Productvcode:        "ap.productvcode",
	Producerclientregid: "ap.producerclientregid",
	Producertype:        "ap.producertype",
	Producerfullname:    "ap.producerfullname",
	Producershortname:   "ap.producershortname",
	Producercountry:     "ap.producercountry",
	Producerregioncode:  "ap.producerregioncode",
	Producerdescription: "ap.producerdescription",
}

// Generated where

type whereHelperstring struct{ field string }

func (w whereHelperstring) EQ(x string) qm.QueryMod    { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperstring) NEQ(x string) qm.QueryMod   { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperstring) LT(x string) qm.QueryMod    { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperstring) LTE(x string) qm.QueryMod   { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperstring) GT(x string) qm.QueryMod    { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperstring) GTE(x string) qm.QueryMod   { return qmhelper.Where(w.field, qmhelper.GTE, x) }
func (w whereHelperstring) LIKE(x string) qm.QueryMod  { return qm.Where(w.field+" LIKE ?", x) }
func (w whereHelperstring) NLIKE(x string) qm.QueryMod { return qm.Where(w.field+" NOT LIKE ?", x) }
func (w whereHelperstring) IN(slice []string) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelperstring) NIN(slice []string) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

type whereHelperint64 struct{ field string }

func (w whereHelperint64) EQ(x int64) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperint64) NEQ(x int64) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperint64) LT(x int64) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperint64) LTE(x int64) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperint64) GT(x int64) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperint64) GTE(x int64) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }
func (w whereHelperint64) IN(slice []int64) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelperint64) NIN(slice []int64) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

var ApWhere = struct {
	Alccode             whereHelperstring
	RequestID           whereHelperint64
	Fullname            whereHelperstring
	Capacity            whereHelperstring
	Unittype            whereHelperstring
	Alcvolume           whereHelperstring
	Packtype            whereHelperstring
	Productvcode        whereHelperstring
	Producerclientregid whereHelperstring
	Producertype        whereHelperstring
	Producerfullname    whereHelperstring
	Producershortname   whereHelperstring
	Producercountry     whereHelperstring
	Producerregioncode  whereHelperstring
	Producerdescription whereHelperstring
}{
	Alccode:             whereHelperstring{field: "\"ap\".\"alccode\""},
	RequestID:           whereHelperint64{field: "\"ap\".\"request_id\""},
	Fullname:            whereHelperstring{field: "\"ap\".\"fullname\""},
	Capacity:            whereHelperstring{field: "\"ap\".\"capacity\""},
	Unittype:            whereHelperstring{field: "\"ap\".\"unittype\""},
	Alcvolume:           whereHelperstring{field: "\"ap\".\"alcvolume\""},
	Packtype:            whereHelperstring{field: "\"ap\".\"packtype\""},
	Productvcode:        whereHelperstring{field: "\"ap\".\"productvcode\""},
	Producerclientregid: whereHelperstring{field: "\"ap\".\"producerclientregid\""},
	Producertype:        whereHelperstring{field: "\"ap\".\"producertype\""},
	Producerfullname:    whereHelperstring{field: "\"ap\".\"producerfullname\""},
	Producershortname:   whereHelperstring{field: "\"ap\".\"producershortname\""},
	Producercountry:     whereHelperstring{field: "\"ap\".\"producercountry\""},
	Producerregioncode:  whereHelperstring{field: "\"ap\".\"producerregioncode\""},
	Producerdescription: whereHelperstring{field: "\"ap\".\"producerdescription\""},
}

// ApRels is where relationship names are stored.
var ApRels = struct {
}{}

// apR is where relationships are stored.
type apR struct {
}

// NewStruct creates a new relationship struct
func (*apR) NewStruct() *apR {
	return &apR{}
}

// apL is where Load methods for each relationship are stored.
type apL struct{}

var (
	apAllColumns            = []string{"alccode", "request_id", "fullname", "capacity", "unittype", "alcvolume", "packtype", "productvcode", "producerclientregid", "producertype", "producerfullname", "producershortname", "producercountry", "producerregioncode", "producerdescription"}
	apColumnsWithoutDefault = []string{"alccode"}
	apColumnsWithDefault    = []string{"request_id", "fullname", "capacity", "unittype", "alcvolume", "packtype", "productvcode", "producerclientregid", "producertype", "producerfullname", "producershortname", "producercountry", "producerregioncode", "producerdescription"}
	apPrimaryKeyColumns     = []string{"alccode"}
	apGeneratedColumns      = []string{}
)

type (
	// ApSlice is an alias for a slice of pointers to Ap.
	// This should almost always be used instead of []Ap.
	ApSlice []*Ap
	// ApHook is the signature for custom Ap hook methods
	ApHook func(context.Context, boil.ContextExecutor, *Ap) error

	apQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	apType                 = reflect.TypeOf(&Ap{})
	apMapping              = queries.MakeStructMapping(apType)
	apPrimaryKeyMapping, _ = queries.BindMapping(apType, apMapping, apPrimaryKeyColumns)
	apInsertCacheMut       sync.RWMutex
	apInsertCache          = make(map[string]insertCache)
	apUpdateCacheMut       sync.RWMutex
	apUpdateCache          = make(map[string]updateCache)
	apUpsertCacheMut       sync.RWMutex
	apUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var apAfterSelectMu sync.Mutex
var apAfterSelectHooks []ApHook

var apBeforeInsertMu sync.Mutex
var apBeforeInsertHooks []ApHook
var apAfterInsertMu sync.Mutex
var apAfterInsertHooks []ApHook

var apBeforeUpdateMu sync.Mutex
var apBeforeUpdateHooks []ApHook
var apAfterUpdateMu sync.Mutex
var apAfterUpdateHooks []ApHook

var apBeforeDeleteMu sync.Mutex
var apBeforeDeleteHooks []ApHook
var apAfterDeleteMu sync.Mutex
var apAfterDeleteHooks []ApHook

var apBeforeUpsertMu sync.Mutex
var apBeforeUpsertHooks []ApHook
var apAfterUpsertMu sync.Mutex
var apAfterUpsertHooks []ApHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Ap) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range apAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Ap) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range apBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Ap) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range apAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Ap) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range apBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Ap) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range apAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Ap) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range apBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Ap) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range apAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Ap) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range apBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Ap) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range apAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddApHook registers your hook function for all future operations.
func AddApHook(hookPoint boil.HookPoint, apHook ApHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		apAfterSelectMu.Lock()
		apAfterSelectHooks = append(apAfterSelectHooks, apHook)
		apAfterSelectMu.Unlock()
	case boil.BeforeInsertHook:
		apBeforeInsertMu.Lock()
		apBeforeInsertHooks = append(apBeforeInsertHooks, apHook)
		apBeforeInsertMu.Unlock()
	case boil.AfterInsertHook:
		apAfterInsertMu.Lock()
		apAfterInsertHooks = append(apAfterInsertHooks, apHook)
		apAfterInsertMu.Unlock()
	case boil.BeforeUpdateHook:
		apBeforeUpdateMu.Lock()
		apBeforeUpdateHooks = append(apBeforeUpdateHooks, apHook)
		apBeforeUpdateMu.Unlock()
	case boil.AfterUpdateHook:
		apAfterUpdateMu.Lock()
		apAfterUpdateHooks = append(apAfterUpdateHooks, apHook)
		apAfterUpdateMu.Unlock()
	case boil.BeforeDeleteHook:
		apBeforeDeleteMu.Lock()
		apBeforeDeleteHooks = append(apBeforeDeleteHooks, apHook)
		apBeforeDeleteMu.Unlock()
	case boil.AfterDeleteHook:
		apAfterDeleteMu.Lock()
		apAfterDeleteHooks = append(apAfterDeleteHooks, apHook)
		apAfterDeleteMu.Unlock()
	case boil.BeforeUpsertHook:
		apBeforeUpsertMu.Lock()
		apBeforeUpsertHooks = append(apBeforeUpsertHooks, apHook)
		apBeforeUpsertMu.Unlock()
	case boil.AfterUpsertHook:
		apAfterUpsertMu.Lock()
		apAfterUpsertHooks = append(apAfterUpsertHooks, apHook)
		apAfterUpsertMu.Unlock()
	}
}

// OneG returns a single ap record from the query using the global executor.
func (q apQuery) OneG(ctx context.Context) (*Ap, error) {
	return q.One(ctx, boil.GetContextDB())
}

// One returns a single ap record from the query.
func (q apQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Ap, error) {
	o := &Ap{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "rq: failed to execute a one query for ap")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// AllG returns all Ap records from the query using the global executor.
func (q apQuery) AllG(ctx context.Context) (ApSlice, error) {
	return q.All(ctx, boil.GetContextDB())
}

// All returns all Ap records from the query.
func (q apQuery) All(ctx context.Context, exec boil.ContextExecutor) (ApSlice, error) {
	var o []*Ap

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "rq: failed to assign all query results to Ap slice")
	}

	if len(apAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// CountG returns the count of all Ap records in the query using the global executor
func (q apQuery) CountG(ctx context.Context) (int64, error) {
	return q.Count(ctx, boil.GetContextDB())
}

// Count returns the count of all Ap records in the query.
func (q apQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "rq: failed to count ap rows")
	}

	return count, nil
}

// ExistsG checks if the row exists in the table using the global executor.
func (q apQuery) ExistsG(ctx context.Context) (bool, error) {
	return q.Exists(ctx, boil.GetContextDB())
}

// Exists checks if the row exists in the table.
func (q apQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "rq: failed to check if ap exists")
	}

	return count > 0, nil
}

// Aps retrieves all the records using an executor.
func Aps(mods ...qm.QueryMod) apQuery {
	mods = append(mods, qm.From("\"ap\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"ap\".*"})
	}

	return apQuery{q}
}

// FindApG retrieves a single record by ID.
func FindApG(ctx context.Context, alccode string, selectCols ...string) (*Ap, error) {
	return FindAp(ctx, boil.GetContextDB(), alccode, selectCols...)
}

// FindAp retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindAp(ctx context.Context, exec boil.ContextExecutor, alccode string, selectCols ...string) (*Ap, error) {
	apObj := &Ap{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"ap\" where \"alccode\"=?", sel,
	)

	q := queries.Raw(query, alccode)

	err := q.Bind(ctx, exec, apObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "rq: unable to select from ap")
	}

	if err = apObj.doAfterSelectHooks(ctx, exec); err != nil {
		return apObj, err
	}

	return apObj, nil
}

// InsertG a single record. See Insert for whitelist behavior description.
func (o *Ap) InsertG(ctx context.Context, columns boil.Columns) error {
	return o.Insert(ctx, boil.GetContextDB(), columns)
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Ap) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("rq: no ap provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(apColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	apInsertCacheMut.RLock()
	cache, cached := apInsertCache[key]
	apInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			apAllColumns,
			apColumnsWithDefault,
			apColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(apType, apMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(apType, apMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"ap\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"ap\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "rq: unable to insert into ap")
	}

	if !cached {
		apInsertCacheMut.Lock()
		apInsertCache[key] = cache
		apInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// UpdateG a single Ap record using the global executor.
// See Update for more documentation.
func (o *Ap) UpdateG(ctx context.Context, columns boil.Columns) (int64, error) {
	return o.Update(ctx, boil.GetContextDB(), columns)
}

// Update uses an executor to update the Ap.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Ap) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	apUpdateCacheMut.RLock()
	cache, cached := apUpdateCache[key]
	apUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			apAllColumns,
			apPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("rq: unable to update ap, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"ap\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 0, wl),
			strmangle.WhereClause("\"", "\"", 0, apPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(apType, apMapping, append(wl, apPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "rq: unable to update ap row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "rq: failed to get rows affected by update for ap")
	}

	if !cached {
		apUpdateCacheMut.Lock()
		apUpdateCache[key] = cache
		apUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAllG updates all rows with the specified column values.
func (q apQuery) UpdateAllG(ctx context.Context, cols M) (int64, error) {
	return q.UpdateAll(ctx, boil.GetContextDB(), cols)
}

// UpdateAll updates all rows with the specified column values.
func (q apQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "rq: unable to update all for ap")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "rq: unable to retrieve rows affected for ap")
	}

	return rowsAff, nil
}

// UpdateAllG updates all rows with the specified column values.
func (o ApSlice) UpdateAllG(ctx context.Context, cols M) (int64, error) {
	return o.UpdateAll(ctx, boil.GetContextDB(), cols)
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o ApSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("rq: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), apPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"ap\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, apPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "rq: unable to update all in ap slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "rq: unable to retrieve rows affected all in update all ap")
	}
	return rowsAff, nil
}

// UpsertG attempts an insert, and does an update or ignore on conflict.
func (o *Ap) UpsertG(ctx context.Context, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	return o.Upsert(ctx, boil.GetContextDB(), updateOnConflict, conflictColumns, updateColumns, insertColumns)
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Ap) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("rq: no ap provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(apColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	apUpsertCacheMut.RLock()
	cache, cached := apUpsertCache[key]
	apUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			apAllColumns,
			apColumnsWithDefault,
			apColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			apAllColumns,
			apPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("rq: unable to upsert ap, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(apPrimaryKeyColumns))
			copy(conflict, apPrimaryKeyColumns)
		}
		cache.query = buildUpsertQuerySQLite(dialect, "\"ap\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(apType, apMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(apType, apMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "rq: unable to upsert ap")
	}

	if !cached {
		apUpsertCacheMut.Lock()
		apUpsertCache[key] = cache
		apUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// DeleteG deletes a single Ap record.
// DeleteG will match against the primary key column to find the record to delete.
func (o *Ap) DeleteG(ctx context.Context) (int64, error) {
	return o.Delete(ctx, boil.GetContextDB())
}

// Delete deletes a single Ap record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Ap) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("rq: no Ap provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), apPrimaryKeyMapping)
	sql := "DELETE FROM \"ap\" WHERE \"alccode\"=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "rq: unable to delete from ap")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "rq: failed to get rows affected by delete for ap")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

func (q apQuery) DeleteAllG(ctx context.Context) (int64, error) {
	return q.DeleteAll(ctx, boil.GetContextDB())
}

// DeleteAll deletes all matching rows.
func (q apQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("rq: no apQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "rq: unable to delete all from ap")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "rq: failed to get rows affected by deleteall for ap")
	}

	return rowsAff, nil
}

// DeleteAllG deletes all rows in the slice.
func (o ApSlice) DeleteAllG(ctx context.Context) (int64, error) {
	return o.DeleteAll(ctx, boil.GetContextDB())
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o ApSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(apBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), apPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"ap\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, apPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "rq: unable to delete all from ap slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "rq: failed to get rows affected by deleteall for ap")
	}

	if len(apAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// ReloadG refetches the object from the database using the primary keys.
func (o *Ap) ReloadG(ctx context.Context) error {
	if o == nil {
		return errors.New("rq: no Ap provided for reload")
	}

	return o.Reload(ctx, boil.GetContextDB())
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Ap) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindAp(ctx, exec, o.Alccode)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAllG refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *ApSlice) ReloadAllG(ctx context.Context) error {
	if o == nil {
		return errors.New("rq: empty ApSlice provided for reload all")
	}

	return o.ReloadAll(ctx, boil.GetContextDB())
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *ApSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := ApSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), apPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"ap\".* FROM \"ap\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, apPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "rq: unable to reload all in ApSlice")
	}

	*o = slice

	return nil
}

// ApExistsG checks if the Ap row exists.
func ApExistsG(ctx context.Context, alccode string) (bool, error) {
	return ApExists(ctx, boil.GetContextDB(), alccode)
}

// ApExists checks if the Ap row exists.
func ApExists(ctx context.Context, exec boil.ContextExecutor, alccode string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"ap\" where \"alccode\"=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, alccode)
	}
	row := exec.QueryRowContext(ctx, sql, alccode)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "rq: unable to check if ap exists")
	}

	return exists, nil
}

// Exists checks if the Ap row exists.
func (o *Ap) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return ApExists(ctx, exec, o.Alccode)
}
