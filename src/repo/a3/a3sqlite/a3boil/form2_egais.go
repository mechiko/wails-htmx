// Code generated by SQLBoiler 4.16.2 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package a3boil

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// Form2Egais is an object representing the database table.
type Form2Egais struct {
	ID                   int64       `boil:"id" json:"id" toml:"id" yaml:"id"`
	IDRequests           null.Int64  `boil:"id_requests" json:"id_requests,omitempty" toml:"id_requests" yaml:"id_requests,omitempty"`
	TTNNumber            null.String `boil:"ttn_number" json:"ttn_number,omitempty" toml:"ttn_number" yaml:"ttn_number,omitempty"`
	TTNDate              null.String `boil:"ttn_date" json:"ttn_date,omitempty" toml:"ttn_date" yaml:"ttn_date,omitempty"`
	ShippingDate         null.String `boil:"shipping_date" json:"shipping_date,omitempty" toml:"shipping_date" yaml:"shipping_date,omitempty"`
	ShipperType          null.String `boil:"shipper_type" json:"shipper_type,omitempty" toml:"shipper_type" yaml:"shipper_type,omitempty"`
	ShipperClientRegID   null.String `boil:"shipper_client_reg_id" json:"shipper_client_reg_id,omitempty" toml:"shipper_client_reg_id" yaml:"shipper_client_reg_id,omitempty"`
	ShipperInn           null.String `boil:"shipper_inn" json:"shipper_inn,omitempty" toml:"shipper_inn" yaml:"shipper_inn,omitempty"`
	ShipperKPP           null.String `boil:"shipper_kpp" json:"shipper_kpp,omitempty" toml:"shipper_kpp" yaml:"shipper_kpp,omitempty"`
	ShipperFullName      null.String `boil:"shipper_full_name" json:"shipper_full_name,omitempty" toml:"shipper_full_name" yaml:"shipper_full_name,omitempty"`
	ShipperShortName     null.String `boil:"shipper_short_name" json:"shipper_short_name,omitempty" toml:"shipper_short_name" yaml:"shipper_short_name,omitempty"`
	ShipperCountryCode   null.String `boil:"shipper_country_code" json:"shipper_country_code,omitempty" toml:"shipper_country_code" yaml:"shipper_country_code,omitempty"`
	ShipperRegionCode    null.String `boil:"shipper_region_code" json:"shipper_region_code,omitempty" toml:"shipper_region_code" yaml:"shipper_region_code,omitempty"`
	ShipperDescription   null.String `boil:"shipper_description" json:"shipper_description,omitempty" toml:"shipper_description" yaml:"shipper_description,omitempty"`
	ConsigneeType        null.String `boil:"consignee_type" json:"consignee_type,omitempty" toml:"consignee_type" yaml:"consignee_type,omitempty"`
	ConsigneeClientRegID null.String `boil:"consignee_client_reg_id" json:"consignee_client_reg_id,omitempty" toml:"consignee_client_reg_id" yaml:"consignee_client_reg_id,omitempty"`
	ConsigneeInn         null.String `boil:"consignee_inn" json:"consignee_inn,omitempty" toml:"consignee_inn" yaml:"consignee_inn,omitempty"`
	ConsigneeKPP         null.String `boil:"consignee_kpp" json:"consignee_kpp,omitempty" toml:"consignee_kpp" yaml:"consignee_kpp,omitempty"`
	ConsigneeFullName    null.String `boil:"consignee_full_name" json:"consignee_full_name,omitempty" toml:"consignee_full_name" yaml:"consignee_full_name,omitempty"`
	ConsigneeShortName   null.String `boil:"consignee_short_name" json:"consignee_short_name,omitempty" toml:"consignee_short_name" yaml:"consignee_short_name,omitempty"`
	ConsigneeCountryCode null.String `boil:"consignee_country_code" json:"consignee_country_code,omitempty" toml:"consignee_country_code" yaml:"consignee_country_code,omitempty"`
	ConsigneeRegionCode  null.String `boil:"consignee_region_code" json:"consignee_region_code,omitempty" toml:"consignee_region_code" yaml:"consignee_region_code,omitempty"`
	ConsigneeDescription null.String `boil:"consignee_description" json:"consignee_description,omitempty" toml:"consignee_description" yaml:"consignee_description,omitempty"`
	ProductFullName      null.String `boil:"product_full_name" json:"product_full_name,omitempty" toml:"product_full_name" yaml:"product_full_name,omitempty"`
	ProductCapacity      null.String `boil:"product_capacity" json:"product_capacity,omitempty" toml:"product_capacity" yaml:"product_capacity,omitempty"`
	ProductAlcVolume     null.String `boil:"product_alc_volume" json:"product_alc_volume,omitempty" toml:"product_alc_volume" yaml:"product_alc_volume,omitempty"`
	ProductAlcCode       null.String `boil:"product_alc_code" json:"product_alc_code,omitempty" toml:"product_alc_code" yaml:"product_alc_code,omitempty"`
	ProductCode          null.String `boil:"product_code" json:"product_code,omitempty" toml:"product_code" yaml:"product_code,omitempty"`
	ProductUnitType      null.String `boil:"product_unit_type" json:"product_unit_type,omitempty" toml:"product_unit_type" yaml:"product_unit_type,omitempty"`
	ProductQuantity      null.String `boil:"product_quantity" json:"product_quantity,omitempty" toml:"product_quantity" yaml:"product_quantity,omitempty"`
	ProductInformF2RegID null.String `boil:"product_inform_f2_reg_id" json:"product_inform_f2_reg_id,omitempty" toml:"product_inform_f2_reg_id" yaml:"product_inform_f2_reg_id,omitempty"`
	ProducerType         null.String `boil:"producer_type" json:"producer_type,omitempty" toml:"producer_type" yaml:"producer_type,omitempty"`
	ProducerClientRegID  null.String `boil:"producer_client_reg_id" json:"producer_client_reg_id,omitempty" toml:"producer_client_reg_id" yaml:"producer_client_reg_id,omitempty"`
	ProducerInn          null.String `boil:"producer_inn" json:"producer_inn,omitempty" toml:"producer_inn" yaml:"producer_inn,omitempty"`
	ProducerKPP          null.String `boil:"producer_kpp" json:"producer_kpp,omitempty" toml:"producer_kpp" yaml:"producer_kpp,omitempty"`
	ProducerFullName     null.String `boil:"producer_full_name" json:"producer_full_name,omitempty" toml:"producer_full_name" yaml:"producer_full_name,omitempty"`
	ProducerShortName    null.String `boil:"producer_short_name" json:"producer_short_name,omitempty" toml:"producer_short_name" yaml:"producer_short_name,omitempty"`
	ProducerCountryCode  null.String `boil:"producer_country_code" json:"producer_country_code,omitempty" toml:"producer_country_code" yaml:"producer_country_code,omitempty"`
	ProducerRegionCode   null.String `boil:"producer_region_code" json:"producer_region_code,omitempty" toml:"producer_region_code" yaml:"producer_region_code,omitempty"`
	ProducerDescription  null.String `boil:"producer_description" json:"producer_description,omitempty" toml:"producer_description" yaml:"producer_description,omitempty"`

	R *form2EgaisR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L form2EgaisL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var Form2EgaisColumns = struct {
	ID                   string
	IDRequests           string
	TTNNumber            string
	TTNDate              string
	ShippingDate         string
	ShipperType          string
	ShipperClientRegID   string
	ShipperInn           string
	ShipperKPP           string
	ShipperFullName      string
	ShipperShortName     string
	ShipperCountryCode   string
	ShipperRegionCode    string
	ShipperDescription   string
	ConsigneeType        string
	ConsigneeClientRegID string
	ConsigneeInn         string
	ConsigneeKPP         string
	ConsigneeFullName    string
	ConsigneeShortName   string
	ConsigneeCountryCode string
	ConsigneeRegionCode  string
	ConsigneeDescription string
	ProductFullName      string
	ProductCapacity      string
	ProductAlcVolume     string
	ProductAlcCode       string
	ProductCode          string
	ProductUnitType      string
	ProductQuantity      string
	ProductInformF2RegID string
	ProducerType         string
	ProducerClientRegID  string
	ProducerInn          string
	ProducerKPP          string
	ProducerFullName     string
	ProducerShortName    string
	ProducerCountryCode  string
	ProducerRegionCode   string
	ProducerDescription  string
}{
	ID:                   "id",
	IDRequests:           "id_requests",
	TTNNumber:            "ttn_number",
	TTNDate:              "ttn_date",
	ShippingDate:         "shipping_date",
	ShipperType:          "shipper_type",
	ShipperClientRegID:   "shipper_client_reg_id",
	ShipperInn:           "shipper_inn",
	ShipperKPP:           "shipper_kpp",
	ShipperFullName:      "shipper_full_name",
	ShipperShortName:     "shipper_short_name",
	ShipperCountryCode:   "shipper_country_code",
	ShipperRegionCode:    "shipper_region_code",
	ShipperDescription:   "shipper_description",
	ConsigneeType:        "consignee_type",
	ConsigneeClientRegID: "consignee_client_reg_id",
	ConsigneeInn:         "consignee_inn",
	ConsigneeKPP:         "consignee_kpp",
	ConsigneeFullName:    "consignee_full_name",
	ConsigneeShortName:   "consignee_short_name",
	ConsigneeCountryCode: "consignee_country_code",
	ConsigneeRegionCode:  "consignee_region_code",
	ConsigneeDescription: "consignee_description",
	ProductFullName:      "product_full_name",
	ProductCapacity:      "product_capacity",
	ProductAlcVolume:     "product_alc_volume",
	ProductAlcCode:       "product_alc_code",
	ProductCode:          "product_code",
	ProductUnitType:      "product_unit_type",
	ProductQuantity:      "product_quantity",
	ProductInformF2RegID: "product_inform_f2_reg_id",
	ProducerType:         "producer_type",
	ProducerClientRegID:  "producer_client_reg_id",
	ProducerInn:          "producer_inn",
	ProducerKPP:          "producer_kpp",
	ProducerFullName:     "producer_full_name",
	ProducerShortName:    "producer_short_name",
	ProducerCountryCode:  "producer_country_code",
	ProducerRegionCode:   "producer_region_code",
	ProducerDescription:  "producer_description",
}

var Form2EgaisTableColumns = struct {
	ID                   string
	IDRequests           string
	TTNNumber            string
	TTNDate              string
	ShippingDate         string
	ShipperType          string
	ShipperClientRegID   string
	ShipperInn           string
	ShipperKPP           string
	ShipperFullName      string
	ShipperShortName     string
	ShipperCountryCode   string
	ShipperRegionCode    string
	ShipperDescription   string
	ConsigneeType        string
	ConsigneeClientRegID string
	ConsigneeInn         string
	ConsigneeKPP         string
	ConsigneeFullName    string
	ConsigneeShortName   string
	ConsigneeCountryCode string
	ConsigneeRegionCode  string
	ConsigneeDescription string
	ProductFullName      string
	ProductCapacity      string
	ProductAlcVolume     string
	ProductAlcCode       string
	ProductCode          string
	ProductUnitType      string
	ProductQuantity      string
	ProductInformF2RegID string
	ProducerType         string
	ProducerClientRegID  string
	ProducerInn          string
	ProducerKPP          string
	ProducerFullName     string
	ProducerShortName    string
	ProducerCountryCode  string
	ProducerRegionCode   string
	ProducerDescription  string
}{
	ID:                   "form2_egais.id",
	IDRequests:           "form2_egais.id_requests",
	TTNNumber:            "form2_egais.ttn_number",
	TTNDate:              "form2_egais.ttn_date",
	ShippingDate:         "form2_egais.shipping_date",
	ShipperType:          "form2_egais.shipper_type",
	ShipperClientRegID:   "form2_egais.shipper_client_reg_id",
	ShipperInn:           "form2_egais.shipper_inn",
	ShipperKPP:           "form2_egais.shipper_kpp",
	ShipperFullName:      "form2_egais.shipper_full_name",
	ShipperShortName:     "form2_egais.shipper_short_name",
	ShipperCountryCode:   "form2_egais.shipper_country_code",
	ShipperRegionCode:    "form2_egais.shipper_region_code",
	ShipperDescription:   "form2_egais.shipper_description",
	ConsigneeType:        "form2_egais.consignee_type",
	ConsigneeClientRegID: "form2_egais.consignee_client_reg_id",
	ConsigneeInn:         "form2_egais.consignee_inn",
	ConsigneeKPP:         "form2_egais.consignee_kpp",
	ConsigneeFullName:    "form2_egais.consignee_full_name",
	ConsigneeShortName:   "form2_egais.consignee_short_name",
	ConsigneeCountryCode: "form2_egais.consignee_country_code",
	ConsigneeRegionCode:  "form2_egais.consignee_region_code",
	ConsigneeDescription: "form2_egais.consignee_description",
	ProductFullName:      "form2_egais.product_full_name",
	ProductCapacity:      "form2_egais.product_capacity",
	ProductAlcVolume:     "form2_egais.product_alc_volume",
	ProductAlcCode:       "form2_egais.product_alc_code",
	ProductCode:          "form2_egais.product_code",
	ProductUnitType:      "form2_egais.product_unit_type",
	ProductQuantity:      "form2_egais.product_quantity",
	ProductInformF2RegID: "form2_egais.product_inform_f2_reg_id",
	ProducerType:         "form2_egais.producer_type",
	ProducerClientRegID:  "form2_egais.producer_client_reg_id",
	ProducerInn:          "form2_egais.producer_inn",
	ProducerKPP:          "form2_egais.producer_kpp",
	ProducerFullName:     "form2_egais.producer_full_name",
	ProducerShortName:    "form2_egais.producer_short_name",
	ProducerCountryCode:  "form2_egais.producer_country_code",
	ProducerRegionCode:   "form2_egais.producer_region_code",
	ProducerDescription:  "form2_egais.producer_description",
}

// Generated where

var Form2EgaisWhere = struct {
	ID                   whereHelperint64
	IDRequests           whereHelpernull_Int64
	TTNNumber            whereHelpernull_String
	TTNDate              whereHelpernull_String
	ShippingDate         whereHelpernull_String
	ShipperType          whereHelpernull_String
	ShipperClientRegID   whereHelpernull_String
	ShipperInn           whereHelpernull_String
	ShipperKPP           whereHelpernull_String
	ShipperFullName      whereHelpernull_String
	ShipperShortName     whereHelpernull_String
	ShipperCountryCode   whereHelpernull_String
	ShipperRegionCode    whereHelpernull_String
	ShipperDescription   whereHelpernull_String
	ConsigneeType        whereHelpernull_String
	ConsigneeClientRegID whereHelpernull_String
	ConsigneeInn         whereHelpernull_String
	ConsigneeKPP         whereHelpernull_String
	ConsigneeFullName    whereHelpernull_String
	ConsigneeShortName   whereHelpernull_String
	ConsigneeCountryCode whereHelpernull_String
	ConsigneeRegionCode  whereHelpernull_String
	ConsigneeDescription whereHelpernull_String
	ProductFullName      whereHelpernull_String
	ProductCapacity      whereHelpernull_String
	ProductAlcVolume     whereHelpernull_String
	ProductAlcCode       whereHelpernull_String
	ProductCode          whereHelpernull_String
	ProductUnitType      whereHelpernull_String
	ProductQuantity      whereHelpernull_String
	ProductInformF2RegID whereHelpernull_String
	ProducerType         whereHelpernull_String
	ProducerClientRegID  whereHelpernull_String
	ProducerInn          whereHelpernull_String
	ProducerKPP          whereHelpernull_String
	ProducerFullName     whereHelpernull_String
	ProducerShortName    whereHelpernull_String
	ProducerCountryCode  whereHelpernull_String
	ProducerRegionCode   whereHelpernull_String
	ProducerDescription  whereHelpernull_String
}{
	ID:                   whereHelperint64{field: "\"form2_egais\".\"id\""},
	IDRequests:           whereHelpernull_Int64{field: "\"form2_egais\".\"id_requests\""},
	TTNNumber:            whereHelpernull_String{field: "\"form2_egais\".\"ttn_number\""},
	TTNDate:              whereHelpernull_String{field: "\"form2_egais\".\"ttn_date\""},
	ShippingDate:         whereHelpernull_String{field: "\"form2_egais\".\"shipping_date\""},
	ShipperType:          whereHelpernull_String{field: "\"form2_egais\".\"shipper_type\""},
	ShipperClientRegID:   whereHelpernull_String{field: "\"form2_egais\".\"shipper_client_reg_id\""},
	ShipperInn:           whereHelpernull_String{field: "\"form2_egais\".\"shipper_inn\""},
	ShipperKPP:           whereHelpernull_String{field: "\"form2_egais\".\"shipper_kpp\""},
	ShipperFullName:      whereHelpernull_String{field: "\"form2_egais\".\"shipper_full_name\""},
	ShipperShortName:     whereHelpernull_String{field: "\"form2_egais\".\"shipper_short_name\""},
	ShipperCountryCode:   whereHelpernull_String{field: "\"form2_egais\".\"shipper_country_code\""},
	ShipperRegionCode:    whereHelpernull_String{field: "\"form2_egais\".\"shipper_region_code\""},
	ShipperDescription:   whereHelpernull_String{field: "\"form2_egais\".\"shipper_description\""},
	ConsigneeType:        whereHelpernull_String{field: "\"form2_egais\".\"consignee_type\""},
	ConsigneeClientRegID: whereHelpernull_String{field: "\"form2_egais\".\"consignee_client_reg_id\""},
	ConsigneeInn:         whereHelpernull_String{field: "\"form2_egais\".\"consignee_inn\""},
	ConsigneeKPP:         whereHelpernull_String{field: "\"form2_egais\".\"consignee_kpp\""},
	ConsigneeFullName:    whereHelpernull_String{field: "\"form2_egais\".\"consignee_full_name\""},
	ConsigneeShortName:   whereHelpernull_String{field: "\"form2_egais\".\"consignee_short_name\""},
	ConsigneeCountryCode: whereHelpernull_String{field: "\"form2_egais\".\"consignee_country_code\""},
	ConsigneeRegionCode:  whereHelpernull_String{field: "\"form2_egais\".\"consignee_region_code\""},
	ConsigneeDescription: whereHelpernull_String{field: "\"form2_egais\".\"consignee_description\""},
	ProductFullName:      whereHelpernull_String{field: "\"form2_egais\".\"product_full_name\""},
	ProductCapacity:      whereHelpernull_String{field: "\"form2_egais\".\"product_capacity\""},
	ProductAlcVolume:     whereHelpernull_String{field: "\"form2_egais\".\"product_alc_volume\""},
	ProductAlcCode:       whereHelpernull_String{field: "\"form2_egais\".\"product_alc_code\""},
	ProductCode:          whereHelpernull_String{field: "\"form2_egais\".\"product_code\""},
	ProductUnitType:      whereHelpernull_String{field: "\"form2_egais\".\"product_unit_type\""},
	ProductQuantity:      whereHelpernull_String{field: "\"form2_egais\".\"product_quantity\""},
	ProductInformF2RegID: whereHelpernull_String{field: "\"form2_egais\".\"product_inform_f2_reg_id\""},
	ProducerType:         whereHelpernull_String{field: "\"form2_egais\".\"producer_type\""},
	ProducerClientRegID:  whereHelpernull_String{field: "\"form2_egais\".\"producer_client_reg_id\""},
	ProducerInn:          whereHelpernull_String{field: "\"form2_egais\".\"producer_inn\""},
	ProducerKPP:          whereHelpernull_String{field: "\"form2_egais\".\"producer_kpp\""},
	ProducerFullName:     whereHelpernull_String{field: "\"form2_egais\".\"producer_full_name\""},
	ProducerShortName:    whereHelpernull_String{field: "\"form2_egais\".\"producer_short_name\""},
	ProducerCountryCode:  whereHelpernull_String{field: "\"form2_egais\".\"producer_country_code\""},
	ProducerRegionCode:   whereHelpernull_String{field: "\"form2_egais\".\"producer_region_code\""},
	ProducerDescription:  whereHelpernull_String{field: "\"form2_egais\".\"producer_description\""},
}

// Form2EgaisRels is where relationship names are stored.
var Form2EgaisRels = struct {
}{}

// form2EgaisR is where relationships are stored.
type form2EgaisR struct {
}

// NewStruct creates a new relationship struct
func (*form2EgaisR) NewStruct() *form2EgaisR {
	return &form2EgaisR{}
}

// form2EgaisL is where Load methods for each relationship are stored.
type form2EgaisL struct{}

var (
	form2EgaisAllColumns            = []string{"id", "id_requests", "ttn_number", "ttn_date", "shipping_date", "shipper_type", "shipper_client_reg_id", "shipper_inn", "shipper_kpp", "shipper_full_name", "shipper_short_name", "shipper_country_code", "shipper_region_code", "shipper_description", "consignee_type", "consignee_client_reg_id", "consignee_inn", "consignee_kpp", "consignee_full_name", "consignee_short_name", "consignee_country_code", "consignee_region_code", "consignee_description", "product_full_name", "product_capacity", "product_alc_volume", "product_alc_code", "product_code", "product_unit_type", "product_quantity", "product_inform_f2_reg_id", "producer_type", "producer_client_reg_id", "producer_inn", "producer_kpp", "producer_full_name", "producer_short_name", "producer_country_code", "producer_region_code", "producer_description"}
	form2EgaisColumnsWithoutDefault = []string{}
	form2EgaisColumnsWithDefault    = []string{"id", "id_requests", "ttn_number", "ttn_date", "shipping_date", "shipper_type", "shipper_client_reg_id", "shipper_inn", "shipper_kpp", "shipper_full_name", "shipper_short_name", "shipper_country_code", "shipper_region_code", "shipper_description", "consignee_type", "consignee_client_reg_id", "consignee_inn", "consignee_kpp", "consignee_full_name", "consignee_short_name", "consignee_country_code", "consignee_region_code", "consignee_description", "product_full_name", "product_capacity", "product_alc_volume", "product_alc_code", "product_code", "product_unit_type", "product_quantity", "product_inform_f2_reg_id", "producer_type", "producer_client_reg_id", "producer_inn", "producer_kpp", "producer_full_name", "producer_short_name", "producer_country_code", "producer_region_code", "producer_description"}
	form2EgaisPrimaryKeyColumns     = []string{"id"}
	form2EgaisGeneratedColumns      = []string{"id"}
)

type (
	// Form2EgaisSlice is an alias for a slice of pointers to Form2Egais.
	// This should almost always be used instead of []Form2Egais.
	Form2EgaisSlice []*Form2Egais
	// Form2EgaisHook is the signature for custom Form2Egais hook methods
	Form2EgaisHook func(context.Context, boil.ContextExecutor, *Form2Egais) error

	form2EgaisQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	form2EgaisType                 = reflect.TypeOf(&Form2Egais{})
	form2EgaisMapping              = queries.MakeStructMapping(form2EgaisType)
	form2EgaisPrimaryKeyMapping, _ = queries.BindMapping(form2EgaisType, form2EgaisMapping, form2EgaisPrimaryKeyColumns)
	form2EgaisInsertCacheMut       sync.RWMutex
	form2EgaisInsertCache          = make(map[string]insertCache)
	form2EgaisUpdateCacheMut       sync.RWMutex
	form2EgaisUpdateCache          = make(map[string]updateCache)
	form2EgaisUpsertCacheMut       sync.RWMutex
	form2EgaisUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var form2EgaisAfterSelectMu sync.Mutex
var form2EgaisAfterSelectHooks []Form2EgaisHook

var form2EgaisBeforeInsertMu sync.Mutex
var form2EgaisBeforeInsertHooks []Form2EgaisHook
var form2EgaisAfterInsertMu sync.Mutex
var form2EgaisAfterInsertHooks []Form2EgaisHook

var form2EgaisBeforeUpdateMu sync.Mutex
var form2EgaisBeforeUpdateHooks []Form2EgaisHook
var form2EgaisAfterUpdateMu sync.Mutex
var form2EgaisAfterUpdateHooks []Form2EgaisHook

var form2EgaisBeforeDeleteMu sync.Mutex
var form2EgaisBeforeDeleteHooks []Form2EgaisHook
var form2EgaisAfterDeleteMu sync.Mutex
var form2EgaisAfterDeleteHooks []Form2EgaisHook

var form2EgaisBeforeUpsertMu sync.Mutex
var form2EgaisBeforeUpsertHooks []Form2EgaisHook
var form2EgaisAfterUpsertMu sync.Mutex
var form2EgaisAfterUpsertHooks []Form2EgaisHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Form2Egais) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range form2EgaisAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Form2Egais) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range form2EgaisBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Form2Egais) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range form2EgaisAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Form2Egais) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range form2EgaisBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Form2Egais) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range form2EgaisAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Form2Egais) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range form2EgaisBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Form2Egais) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range form2EgaisAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Form2Egais) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range form2EgaisBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Form2Egais) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range form2EgaisAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddForm2EgaisHook registers your hook function for all future operations.
func AddForm2EgaisHook(hookPoint boil.HookPoint, form2EgaisHook Form2EgaisHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		form2EgaisAfterSelectMu.Lock()
		form2EgaisAfterSelectHooks = append(form2EgaisAfterSelectHooks, form2EgaisHook)
		form2EgaisAfterSelectMu.Unlock()
	case boil.BeforeInsertHook:
		form2EgaisBeforeInsertMu.Lock()
		form2EgaisBeforeInsertHooks = append(form2EgaisBeforeInsertHooks, form2EgaisHook)
		form2EgaisBeforeInsertMu.Unlock()
	case boil.AfterInsertHook:
		form2EgaisAfterInsertMu.Lock()
		form2EgaisAfterInsertHooks = append(form2EgaisAfterInsertHooks, form2EgaisHook)
		form2EgaisAfterInsertMu.Unlock()
	case boil.BeforeUpdateHook:
		form2EgaisBeforeUpdateMu.Lock()
		form2EgaisBeforeUpdateHooks = append(form2EgaisBeforeUpdateHooks, form2EgaisHook)
		form2EgaisBeforeUpdateMu.Unlock()
	case boil.AfterUpdateHook:
		form2EgaisAfterUpdateMu.Lock()
		form2EgaisAfterUpdateHooks = append(form2EgaisAfterUpdateHooks, form2EgaisHook)
		form2EgaisAfterUpdateMu.Unlock()
	case boil.BeforeDeleteHook:
		form2EgaisBeforeDeleteMu.Lock()
		form2EgaisBeforeDeleteHooks = append(form2EgaisBeforeDeleteHooks, form2EgaisHook)
		form2EgaisBeforeDeleteMu.Unlock()
	case boil.AfterDeleteHook:
		form2EgaisAfterDeleteMu.Lock()
		form2EgaisAfterDeleteHooks = append(form2EgaisAfterDeleteHooks, form2EgaisHook)
		form2EgaisAfterDeleteMu.Unlock()
	case boil.BeforeUpsertHook:
		form2EgaisBeforeUpsertMu.Lock()
		form2EgaisBeforeUpsertHooks = append(form2EgaisBeforeUpsertHooks, form2EgaisHook)
		form2EgaisBeforeUpsertMu.Unlock()
	case boil.AfterUpsertHook:
		form2EgaisAfterUpsertMu.Lock()
		form2EgaisAfterUpsertHooks = append(form2EgaisAfterUpsertHooks, form2EgaisHook)
		form2EgaisAfterUpsertMu.Unlock()
	}
}

// OneG returns a single form2Egais record from the query using the global executor.
func (q form2EgaisQuery) OneG(ctx context.Context) (*Form2Egais, error) {
	return q.One(ctx, boil.GetContextDB())
}

// One returns a single form2Egais record from the query.
func (q form2EgaisQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Form2Egais, error) {
	o := &Form2Egais{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "a3boil: failed to execute a one query for form2_egais")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// AllG returns all Form2Egais records from the query using the global executor.
func (q form2EgaisQuery) AllG(ctx context.Context) (Form2EgaisSlice, error) {
	return q.All(ctx, boil.GetContextDB())
}

// All returns all Form2Egais records from the query.
func (q form2EgaisQuery) All(ctx context.Context, exec boil.ContextExecutor) (Form2EgaisSlice, error) {
	var o []*Form2Egais

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "a3boil: failed to assign all query results to Form2Egais slice")
	}

	if len(form2EgaisAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// CountG returns the count of all Form2Egais records in the query using the global executor
func (q form2EgaisQuery) CountG(ctx context.Context) (int64, error) {
	return q.Count(ctx, boil.GetContextDB())
}

// Count returns the count of all Form2Egais records in the query.
func (q form2EgaisQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "a3boil: failed to count form2_egais rows")
	}

	return count, nil
}

// ExistsG checks if the row exists in the table using the global executor.
func (q form2EgaisQuery) ExistsG(ctx context.Context) (bool, error) {
	return q.Exists(ctx, boil.GetContextDB())
}

// Exists checks if the row exists in the table.
func (q form2EgaisQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "a3boil: failed to check if form2_egais exists")
	}

	return count > 0, nil
}

// Form2Egaiss retrieves all the records using an executor.
func Form2Egaiss(mods ...qm.QueryMod) form2EgaisQuery {
	mods = append(mods, qm.From("\"form2_egais\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"form2_egais\".*"})
	}

	return form2EgaisQuery{q}
}

// FindForm2EgaisG retrieves a single record by ID.
func FindForm2EgaisG(ctx context.Context, iD int64, selectCols ...string) (*Form2Egais, error) {
	return FindForm2Egais(ctx, boil.GetContextDB(), iD, selectCols...)
}

// FindForm2Egais retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindForm2Egais(ctx context.Context, exec boil.ContextExecutor, iD int64, selectCols ...string) (*Form2Egais, error) {
	form2EgaisObj := &Form2Egais{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"form2_egais\" where \"id\"=?", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, form2EgaisObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "a3boil: unable to select from form2_egais")
	}

	if err = form2EgaisObj.doAfterSelectHooks(ctx, exec); err != nil {
		return form2EgaisObj, err
	}

	return form2EgaisObj, nil
}

// InsertG a single record. See Insert for whitelist behavior description.
func (o *Form2Egais) InsertG(ctx context.Context, columns boil.Columns) error {
	return o.Insert(ctx, boil.GetContextDB(), columns)
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Form2Egais) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("a3boil: no form2_egais provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(form2EgaisColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	form2EgaisInsertCacheMut.RLock()
	cache, cached := form2EgaisInsertCache[key]
	form2EgaisInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			form2EgaisAllColumns,
			form2EgaisColumnsWithDefault,
			form2EgaisColumnsWithoutDefault,
			nzDefaults,
		)
		wl = strmangle.SetComplement(wl, form2EgaisGeneratedColumns)

		cache.valueMapping, err = queries.BindMapping(form2EgaisType, form2EgaisMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(form2EgaisType, form2EgaisMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"form2_egais\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"form2_egais\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "a3boil: unable to insert into form2_egais")
	}

	if !cached {
		form2EgaisInsertCacheMut.Lock()
		form2EgaisInsertCache[key] = cache
		form2EgaisInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// UpdateG a single Form2Egais record using the global executor.
// See Update for more documentation.
func (o *Form2Egais) UpdateG(ctx context.Context, columns boil.Columns) (int64, error) {
	return o.Update(ctx, boil.GetContextDB(), columns)
}

// Update uses an executor to update the Form2Egais.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Form2Egais) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	form2EgaisUpdateCacheMut.RLock()
	cache, cached := form2EgaisUpdateCache[key]
	form2EgaisUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			form2EgaisAllColumns,
			form2EgaisPrimaryKeyColumns,
		)
		wl = strmangle.SetComplement(wl, form2EgaisGeneratedColumns)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("a3boil: unable to update form2_egais, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"form2_egais\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 0, wl),
			strmangle.WhereClause("\"", "\"", 0, form2EgaisPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(form2EgaisType, form2EgaisMapping, append(wl, form2EgaisPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "a3boil: unable to update form2_egais row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "a3boil: failed to get rows affected by update for form2_egais")
	}

	if !cached {
		form2EgaisUpdateCacheMut.Lock()
		form2EgaisUpdateCache[key] = cache
		form2EgaisUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAllG updates all rows with the specified column values.
func (q form2EgaisQuery) UpdateAllG(ctx context.Context, cols M) (int64, error) {
	return q.UpdateAll(ctx, boil.GetContextDB(), cols)
}

// UpdateAll updates all rows with the specified column values.
func (q form2EgaisQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "a3boil: unable to update all for form2_egais")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "a3boil: unable to retrieve rows affected for form2_egais")
	}

	return rowsAff, nil
}

// UpdateAllG updates all rows with the specified column values.
func (o Form2EgaisSlice) UpdateAllG(ctx context.Context, cols M) (int64, error) {
	return o.UpdateAll(ctx, boil.GetContextDB(), cols)
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o Form2EgaisSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("a3boil: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), form2EgaisPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"form2_egais\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, form2EgaisPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "a3boil: unable to update all in form2Egais slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "a3boil: unable to retrieve rows affected all in update all form2Egais")
	}
	return rowsAff, nil
}

// UpsertG attempts an insert, and does an update or ignore on conflict.
func (o *Form2Egais) UpsertG(ctx context.Context, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	return o.Upsert(ctx, boil.GetContextDB(), updateOnConflict, conflictColumns, updateColumns, insertColumns)
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Form2Egais) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("a3boil: no form2_egais provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(form2EgaisColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	form2EgaisUpsertCacheMut.RLock()
	cache, cached := form2EgaisUpsertCache[key]
	form2EgaisUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			form2EgaisAllColumns,
			form2EgaisColumnsWithDefault,
			form2EgaisColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			form2EgaisAllColumns,
			form2EgaisPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("a3boil: unable to upsert form2_egais, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(form2EgaisPrimaryKeyColumns))
			copy(conflict, form2EgaisPrimaryKeyColumns)
		}
		cache.query = buildUpsertQuerySQLite(dialect, "\"form2_egais\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(form2EgaisType, form2EgaisMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(form2EgaisType, form2EgaisMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "a3boil: unable to upsert form2_egais")
	}

	if !cached {
		form2EgaisUpsertCacheMut.Lock()
		form2EgaisUpsertCache[key] = cache
		form2EgaisUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// DeleteG deletes a single Form2Egais record.
// DeleteG will match against the primary key column to find the record to delete.
func (o *Form2Egais) DeleteG(ctx context.Context) (int64, error) {
	return o.Delete(ctx, boil.GetContextDB())
}

// Delete deletes a single Form2Egais record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Form2Egais) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("a3boil: no Form2Egais provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), form2EgaisPrimaryKeyMapping)
	sql := "DELETE FROM \"form2_egais\" WHERE \"id\"=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "a3boil: unable to delete from form2_egais")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "a3boil: failed to get rows affected by delete for form2_egais")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

func (q form2EgaisQuery) DeleteAllG(ctx context.Context) (int64, error) {
	return q.DeleteAll(ctx, boil.GetContextDB())
}

// DeleteAll deletes all matching rows.
func (q form2EgaisQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("a3boil: no form2EgaisQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "a3boil: unable to delete all from form2_egais")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "a3boil: failed to get rows affected by deleteall for form2_egais")
	}

	return rowsAff, nil
}

// DeleteAllG deletes all rows in the slice.
func (o Form2EgaisSlice) DeleteAllG(ctx context.Context) (int64, error) {
	return o.DeleteAll(ctx, boil.GetContextDB())
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o Form2EgaisSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(form2EgaisBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), form2EgaisPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"form2_egais\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, form2EgaisPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "a3boil: unable to delete all from form2Egais slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "a3boil: failed to get rows affected by deleteall for form2_egais")
	}

	if len(form2EgaisAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// ReloadG refetches the object from the database using the primary keys.
func (o *Form2Egais) ReloadG(ctx context.Context) error {
	if o == nil {
		return errors.New("a3boil: no Form2Egais provided for reload")
	}

	return o.Reload(ctx, boil.GetContextDB())
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Form2Egais) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindForm2Egais(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAllG refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *Form2EgaisSlice) ReloadAllG(ctx context.Context) error {
	if o == nil {
		return errors.New("a3boil: empty Form2EgaisSlice provided for reload all")
	}

	return o.ReloadAll(ctx, boil.GetContextDB())
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *Form2EgaisSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := Form2EgaisSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), form2EgaisPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"form2_egais\".* FROM \"form2_egais\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, form2EgaisPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "a3boil: unable to reload all in Form2EgaisSlice")
	}

	*o = slice

	return nil
}

// Form2EgaisExistsG checks if the Form2Egais row exists.
func Form2EgaisExistsG(ctx context.Context, iD int64) (bool, error) {
	return Form2EgaisExists(ctx, boil.GetContextDB(), iD)
}

// Form2EgaisExists checks if the Form2Egais row exists.
func Form2EgaisExists(ctx context.Context, exec boil.ContextExecutor, iD int64) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"form2_egais\" where \"id\"=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "a3boil: unable to check if form2_egais exists")
	}

	return exists, nil
}

// Exists checks if the Form2Egais row exists.
func (o *Form2Egais) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return Form2EgaisExists(ctx, exec, o.ID)
}
